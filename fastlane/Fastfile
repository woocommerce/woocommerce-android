# frozen_string_literal: true

default_platform(:android)
fastlane_require 'dotenv'

UI.user_error!('Please run fastlane via `bundle exec`') unless FastlaneCore::Helper.bundler?

########################################################################
# Constants
########################################################################
# The valid values for `app:` parameter, i.e. the two possible top-level modules we can build (mobile and wear app)
MOBILE_APP = 'WooCommerce'
WEAR_APP = 'WooCommerce-Wear'

PROJECT_ROOT_FOLDER = File.dirname(File.expand_path(__dir__))
BUILD_GRADLE_PATH = File.join(PROJECT_ROOT_FOLDER, 'build.gradle')
BUILD_PRODUCTS_PATH = File.join(PROJECT_ROOT_FOLDER, 'artifacts')
PROTOTYPE_BUILD_DOMAIN = 'https://d2twmm2nzpx3bg.cloudfront.net'
# The `android_download_translations` action joins the `RES_DIR_PATH` with `PROJECT_ROOT_FOLDER`, so we don't want to
# add `PROJECT_ROOT_FOLDER` to the beginning of this path
RES_DIR_PATH = File.join('WooCommerce', 'src', 'main', 'res')
MAIN_STRINGS_PATH = File.join(PROJECT_ROOT_FOLDER, RES_DIR_PATH, 'values', 'strings.xml')
VERSION_PROPERTIES_PATH = File.join(PROJECT_ROOT_FOLDER, 'version.properties')
# The metadata for the Play Store live in the Fastlane folder, hence the `Dir.pwd`
METADATA_DIR_PATH = {
  MOBILE_APP => File.join(Dir.pwd, 'metadata', 'android'),
  WEAR_APP => File.join(Dir.pwd, 'metadata', 'wear')
}.freeze
METADATA_SOURCE_DIR_PATH = {
  MOBILE_APP => File.join(METADATA_DIR_PATH[MOBILE_APP], 'en-US'),
  WEAR_APP => File.join(METADATA_DIR_PATH[WEAR_APP], 'en-US')
}.freeze
METADATA_SOURCE_CHANGELOG_FILE_PATH = {
  MOBILE_APP => File.join(METADATA_SOURCE_DIR_PATH[MOBILE_APP], 'changelogs', 'default.txt'),
  WEAR_APP => File.join(METADATA_SOURCE_DIR_PATH[WEAR_APP], 'changelogs', 'default.txt')
}.freeze
DEV_RELEASE_NOTES_PATH = File.join(PROJECT_ROOT_FOLDER, 'RELEASE-NOTES.txt')
RAW_SCREENSHOTS_DIR = File.join(Dir.pwd, 'screenshots', 'raw')
RAW_SCREENSHOTS_PROCESSING_DIR = File.join(Dir.pwd, 'screenshots', 'raw_tmp')
PROMO_SCREENSHOTS_DIR = File.join(Dir.pwd, 'screenshots', 'promo_screenshots')
FROZEN_STRINGS_PATH = File.join(Dir.pwd, 'resources', 'values', 'strings.xml')
REMOTE_LIBRARIES_STRINGS_PATHS = [
  {
    name: 'Login Library',
    import_key: 'wordPressLoginVersion',
    repository: 'wordpress-mobile/WordPress-Login-Flow-Android',
    strings_file_path: 'WordPressLoginFlow/src/main/res/values/strings.xml',
    exclusions: ['default_web_client_id']
  },
  {
    name: 'About Library',
    import_key: 'aboutAutomatticVersion', # key used in build.gradle to reference the version
    repository: 'Automattic/about-automattic-android',
    strings_file_path: 'library/src/main/res/values/strings.xml',
    exclusions: []
  }
].freeze

# URL of the GlotPress project containing the app's strings
GLOTPRESS_APP_STRINGS_PROJECT_URL = 'https://translate.wordpress.com/projects/woocommerce/woocommerce-android/'
# URL of the GlotPress project containing the Play Store metadata (title, keywords, release notes, …)
GLOTPRESS_PLAYSTORE_METADATA_PROJECT_URL = "#{GLOTPRESS_APP_STRINGS_PROJECT_URL}/release-notes/".freeze

APP_PACKAGE_NAME = 'com.woocommerce.android'
GOOGLE_FIREBASE_SECRETS_PATH = File.join(PROJECT_ROOT_FOLDER, '.configure-files', 'firebase.secrets.json')

# Instantiate versioning classes
VERSION_CALCULATOR = Fastlane::Wpmreleasetoolkit::Versioning::MarketingVersionCalculator.new
VERSION_FORMATTER = Fastlane::Wpmreleasetoolkit::Versioning::RCNotationVersionFormatter.new
BUILD_CODE_FORMATTER = Fastlane::Wpmreleasetoolkit::Versioning::SimpleBuildCodeFormatter.new
BUILD_CODE_CALCULATOR = Fastlane::Wpmreleasetoolkit::Versioning::SimpleBuildCodeCalculator.new
VERSION_FILE = Fastlane::Wpmreleasetoolkit::Versioning::AndroidVersionFile.new(version_properties_path: VERSION_PROPERTIES_PATH)

########################################################################
# Environment
########################################################################
Dotenv.load('~/.wcandroid-env.default')
GITHUB_REPO = 'woocommerce/woocommerce-android'
DEFAULT_BRANCH = 'trunk'
REPOSITORY_NAME = 'woocommerce-android'
GH_ORG_NAME = 'woocommerce'

UPLOAD_TO_PLAY_STORE_JSON_KEY = File.join(Dir.home, '.configure', 'woocommerce-android', 'secrets', 'google-upload-credentials.json')

SUPPORTED_LOCALES = [
  { glotpress: 'ar', android: 'ar', google_play: 'ar', promo_config: {} },
  { glotpress: 'de', android: 'de', google_play: 'de-DE',  promo_config: {} },
  { glotpress: 'es', android: 'es', google_play: 'es-ES',  promo_config: {} },
  { glotpress: 'fr', android: 'fr', google_play: 'fr-FR',  promo_config: {} },
  { glotpress: 'he', android: 'he', google_play: 'iw-IL',  promo_config: {} },
  { glotpress: 'id', android: 'id', google_play: 'id', promo_config: {} },
  { glotpress: 'it', android: 'it', google_play: 'it-IT',  promo_config: {} },
  { glotpress: 'ja', android: 'ja', google_play: 'ja-JP',  promo_config: {} },
  { glotpress: 'ko', android: 'ko', google_play: 'ko-KR',  promo_config: {} },
  { glotpress: 'nl', android: 'nl', google_play: 'nl-NL',  promo_config: {} },
  { glotpress: 'pt-br', android: 'pt-rBR', google_play: 'pt-BR', promo_config: {} },
  { glotpress: 'ru', android: 'ru', google_play: 'ru-RU',  promo_config: {} },
  { glotpress: 'sv', android: 'sv', google_play: 'sv-SE',  promo_config: {} },
  { glotpress: 'tr', android: 'tr', google_play: 'tr-TR',  promo_config: {} },
  { glotpress: 'zh-cn', android: 'zh-rCN', google_play: 'zh-CN',  promo_config: {} },
  { glotpress: 'zh-tw', android: 'zh-rTW', google_play: 'zh-TW',  promo_config: {} }
].freeze

platform :android do
  ########################################################################
  # Release Lanes
  ########################################################################

  # This lane executes the steps planned on code freeze, creating new release branch from the current trunk.
  #
  # @param [Boolean] skip_confirm (default: false) If set, will skip the confirmation prompt before running the rest of the lane
  #
  # @example Running the lane
  #          bundle exec fastlane start_code_freeze skip_confirm:true
  #
  lane :start_code_freeze do |skip_confirm: false|
    ensure_git_status_clean

    # Check out the up-to-date default branch, the designated starting point for the code freeze
    Fastlane::Helper::GitHelper.checkout_and_pull(DEFAULT_BRANCH)

    message = <<-MESSAGE

    Code Freeze:
      • New release branch from #{DEFAULT_BRANCH}: release/#{release_version_next}
      • Current release version and build code: #{release_version_current} (#{build_code_current}).
      • New beta version and build code: #{beta_version_first} (#{build_code_next}).

    MESSAGE

    UI.important(message)
    UI.user_error!("Terminating as requested. Don't forget to run the remainder of this automation manually.") unless skip_confirm || UI.confirm('Do you want to continue?')

    # Create the release branch
    UI.message 'Creating release branch...'
    Fastlane::Helper::GitHelper.create_branch("release/#{release_version_next}", from: DEFAULT_BRANCH)
    UI.success("Done! New release branch is: #{git_branch}")

    # Bump the version and build code
    UI.message 'Bumping beta version and build code...'
    VERSION_FILE.write_version(
      version_name: beta_version_first,
      version_code: build_code_next
    )
    commit_version_bump
    UI.success("Done! New Beta Version: #{version_name_current}. New Build Code: #{build_code_current}")

    new_version = release_version_current

    # Extract dev release notes to `fastlane/metadata/android/en-US/changelogs/default.txt`
    extract_release_notes_for_version(
      version: new_version,
      release_notes_file_path: DEV_RELEASE_NOTES_PATH,
      extracted_notes_file_path: METADATA_SOURCE_CHANGELOG_FILE_PATH[MOBILE_APP]
    )
    # Empty the `fastlane/metadata/wear/en-US/changelogs/default.txt` file to avoid accidentally still having notes from previous release
    # It will be up to the Release Manager to fill that file with user-friendly release notes manually before calling `complete_code_freeze`.
    File.write(METADATA_SOURCE_CHANGELOG_FILE_PATH[WEAR_APP], '')

    # Add new section header at the top of the dev release notes file ready for next version
    android_update_release_notes(
      new_version: new_version,
      release_notes_file_path: DEV_RELEASE_NOTES_PATH
    )

    UI.important('Pushing changes to remote and configuring the release on GitHub')
    UI.user_error!("Terminating as requested. Don't forget to run the remainder of this automation manually.") unless skip_confirm || UI.confirm('Do you want to continue?')

    push_to_git_remote(tags: false)

    # Protect release/* branch
    copy_branch_protection(
      repository: GITHUB_REPO,
      from_branch: DEFAULT_BRANCH,
      to_branch: "release/#{new_version}"
    )
    # Add ❄️ marker to milestone title to indicate we entered code-freeze
    set_milestone_frozen_marker(
      repository: GITHUB_REPO,
      milestone: new_version
    )

    # Move PRs to next milestone
    moved_prs = update_assigned_milestone(
      repository: GITHUB_REPO,
      from_milestone: new_version,
      to_milestone: release_version_next,
      comment: "Version `#{new_version}` has now entered code-freeze, so the milestone of this PR has been updated to `#{release_version_next}`."
    )
    UI.message("Moved the following PRs to milestone #{release_version_next}: #{moved_prs.join(', ')}")

    # Annotate the build with the moved PRs
    moved_prs_info = if moved_prs.empty?
                       "👍 No open PR were targeting `#{new_version}` at the time of code-freeze"
                     else
                       "#{moved_prs.count} PRs targeting `#{new_version}` were still open and thus moved to `#{release_version_next}`:\n" \
                         + moved_prs.map { |pr_num| "[##{pr_num}](https://github.com/#{GITHUB_REPO}/pull/#{pr_num})" }.join(', ')
                     end

    buildkite_annotate(style: moved_prs.empty? ? 'success' : 'warning', context: 'start-code-freeze-wcios', message: moved_prs_info) if is_ci
  end

  # This lane executes the last steps planned on code freeze, creating a new release branch from the current trunk
  #
  # @param [Boolean] skip_confirm (default: false) If set, will skip the confirmation prompt before running the rest of the lane
  # @param [Boolean] include_wear_app (default: false) If true, the CI build will also include a job to build the WEAR_APP
  #
  # @example Running the lane
  #          bundle exec fastlane complete_code_freeze skip_confirm:true include_wear_app:true
  #
  lane :complete_code_freeze do |skip_confirm: false, include_wear_app: false|
    check_for_toolkit_updates unless is_ci || ENV['FASTLANE_SKIP_TOOLKIT_UPDATE_CHECK']

    # Verify that there's nothing in progress in the working copy
    ensure_git_status_clean

    ensure_git_branch_is_release_branch

    UI.important("Completing code freeze for: #{release_version_current}")
    UI.user_error!("Terminating as requested. Don't forget to run the remainder of this automation manually.") unless skip_confirm || UI.confirm('Do you want to continue?')

    update_play_store_strings
    localize_libs
    freeze_strings_for_translation

    push_to_git_remote(tags: false)

    trigger_release_build(branch_to_build: "release/#{release_version_current}", include_wear_app: include_wear_app)

    create_backmerge_pr(version: release_version_current)
  end

  # Updates the `PlayStoreStrings.pot` file with the latest content from the `release_notes.txt` files and the other text sources.
  #
  # The `PlayStoreStrings.pot` file is imported into GlotPress regularly via a WPCOM cron job
  # See https://opengrok.a8c.com/source/xref/wpcom/bin/i18n/import-github-originals.php?r=accd6334#35-40
  #
  # @param [String] version The current `x.y` version of the app. Optional. Used to derive the `release_notes_xy` key to use in the `.pot` file.
  #
  # @example Running the lane
  #          bundle exec fastlane update_play_store_strings version:10.3
  #
  lane :update_play_store_strings do |version: release_version_current|
    ensure_git_status_clean

    app_metadata_source_path = METADATA_SOURCE_DIR_PATH[MOBILE_APP]
    files = {
      release_note: METADATA_SOURCE_CHANGELOG_FILE_PATH[MOBILE_APP],
      wear_release_note: METADATA_SOURCE_CHANGELOG_FILE_PATH[WEAR_APP],
      play_store_promo: File.join(app_metadata_source_path, 'short_description.txt'),
      play_store_desc: File.join(app_metadata_source_path, 'full_description.txt'),
      play_store_app_title: File.join(app_metadata_source_path, 'title.txt'),
      play_store_screenshot_1: File.join(app_metadata_source_path, 'promo_screenshot_1.txt'),
      play_store_screenshot_2: File.join(app_metadata_source_path, 'promo_screenshot_2.txt'),
      play_store_screenshot_3: File.join(app_metadata_source_path, 'promo_screenshot_3.txt'),
      play_store_screenshot_4: File.join(app_metadata_source_path, 'promo_screenshot_4.txt'),
      play_store_screenshot_5: File.join(app_metadata_source_path, 'promo_screenshot_5.txt')
    }

    po_path = File.join('fastlane', 'metadata', 'PlayStoreStrings.pot')

    an_update_metadata_source(
      po_file_path: po_path,
      source_files: files,
      release_version: version
    )

    deleted_files = delete_old_changelogs

    git_add(path: [po_path, *deleted_files])
    git_commit(
      path: [po_path, *deleted_files],
      message: "Update `PlayStoreStrings.po` for #{version}",
      allow_nothing_to_commit: true
    )
  end

  #####################################################################################
  # new_beta_release
  #
  # This lane updates the release branch for a new beta release. It will update the
  # current release branch by default.
  #
  # @param [Boolean] skip_confirm Skip the confirmation prompt if set to true
  # @param [Boolean] include_wear_app If true, the CI build will also include a job to build the WEAR_APP. Defaults to false.
  #
  desc 'Updates a release branch for a new beta release'
  lane :new_beta_release do |skip_confirm: false, include_wear_app: false|
    # Verify that there's nothing in progress in the working copy
    ensure_git_status_clean

    ensure_git_branch_is_release_branch

    # Check versions
    message = <<-MESSAGE

      Current beta version: #{version_name_current}
      New beta version: #{beta_version_next}

      Current build code: #{build_code_current}
      New build code: #{build_code_next}

    MESSAGE

    UI.important(message)
    UI.user_error!("Terminating as requested. Don't forget to run the remainder of this automation manually.") unless skip_confirm || UI.confirm('Do you want to continue?')

    # Bump the release version and build code
    UI.message 'Bumping beta version and build code...'
    ensure_git_branch_is_release_branch
    VERSION_FILE.write_version(
      version_name: beta_version_next,
      version_code: build_code_next
    )
    commit_version_bump
    UI.success("Done! New Beta Version: #{version_name_current}. New Build Code: #{build_code_current}")

    UI.important('Pushing changes to remote and triggering the beta build')
    UI.user_error!("Terminating as requested. Don't forget to run the remainder of this automation manually.") unless skip_confirm || UI.confirm('Do you want to continue?')

    push_to_git_remote(tags: false)

    trigger_release_build(branch_to_build: "release/#{release_version_current}", include_wear_app: include_wear_app)

    create_backmerge_pr(version: release_version_current)
  end

  #####################################################################################
  # new_hotfix_release
  #
  # This lane updates the release branch for a new hotfix release.
  #
  # @param [String] version_name The versionName to give the hotfix, e.g. `24.3.1`
  # @param [Int] version_code The versionCode to use for the hotfix build
  # @param [Boolean] skip_confirm Skip the confirmation prompt if set to true
  #
  desc 'Prepare a new hotfix branch cut from the previous tag, and bump the version'
  lane :new_hotfix_release do |version_name:, version_code:, skip_confirm: false|
    # Verify that there's nothing in progress in the working copy
    ensure_git_status_clean

    # Parse the provided version into an AppVersion object
    parsed_version = VERSION_FORMATTER.parse(version_name)
    previous_version = VERSION_FORMATTER.release_version(VERSION_CALCULATOR.previous_patch_version(version: parsed_version))

    # Check versions
    message = <<-MESSAGE

      Current release version: #{release_version_current}
      New hotfix version: #{version_name}

      Current build code: #{build_code_current}
      New build code: #{version_code}

      Branching from tag: #{previous_version}

    MESSAGE

    UI.important(message)
    UI.user_error!("Terminating as requested. Don't forget to run the remainder of this automation manually.") unless skip_confirm || UI.confirm('Do you want to continue?')

    # Check tags
    UI.user_error!("The version `#{version_name}` tag already exists!") if git_tag_exists(tag: version_name)
    UI.user_error!("Version #{previous_version} is not tagged! A hotfix branch cannot be created.") unless git_tag_exists(tag: previous_version)

    # Create the hotfix branch
    UI.message('Creating hotfix branch...')
    Fastlane::Helper::GitHelper.create_branch("release/#{version_name}", from: previous_version)
    UI.success("Done! New hotfix branch is: #{git_branch}")

    # Bump the hotfix version and build code and write it to the `version.properties` file
    UI.message('Bumping hotfix version and build code...')
    VERSION_FILE.write_version(
      version_name: version_name,
      version_code: version_code
    )
    commit_version_bump
    UI.success("Done! New Release Version: #{release_version_current}. New Build Code: #{build_code_current}")

    UI.important('Pushing new hotfix branch to remote...')

    push_to_git_remote(tags: false)
  end

  # This lane finalizes the hotfix branch, triggering a release build.
  #
  # @param [Boolean] skip_confirm (default: false) If set, will skip the confirmation prompt before running the rest of the lane
  # @param [Boolean] include_wear_app (default: false) If true, the CI build will also include a job to build the WEAR_APP
  #
  # @example Running the lane
  #          bundle exec fastlane finalize_hotfix_release skip_confirm:true include_wear_app:true
  #
  lane :finalize_hotfix_release do |skip_confirm: false, include_wear_app: false|
    ensure_git_status_clean

    ensure_git_branch_is_release_branch

    hotfix_version = release_version_current

    UI.important("Triggering hotfix build for version: #{hotfix_version}")
    UI.user_error!("Terminating as requested. Don't forget to run the remainder of this automation manually.") unless skip_confirm || UI.confirm('Do you want to continue?')

    trigger_release_build(branch_to_build: "release/#{hotfix_version}", include_wear_app: include_wear_app)

    create_backmerge_pr(version: hotfix_version)

    # Close hotfix milestone
    begin
      close_milestone(
        repository: GITHUB_REPO,
        milestone: hotfix_version
      )
    rescue StandardError => e
      error_message = <<-MESSAGE
        Error closing milestone `#{hotfix_version}`: #{e.message}
        - If this is a retry of the lane, the milestone might have already been closed and this error is expected.
        - If this is the first run of the lane, please investigate the error.
      MESSAGE

      UI.error(error_message)

      buildkite_annotate(style: 'warning', context: 'finalize-hotfix-error-closing-milestone', message: error_message) if is_ci
    end
  end

  #####################################################################################
  # download_translations
  # -----------------------------------------------------------------------------------
  # This lane downloads the string translations from GlotPress
  # -----------------------------------------------------------------------------------
  # Usage:
  # bundle exec fastlane download_translations
  #####################################################################################
  desc 'Download the latest app translations from GlotPress and update the strings.xml files accordingly'
  lane :download_translations do
    android_download_translations(
      res_dir: RES_DIR_PATH,
      glotpress_url: GLOTPRESS_APP_STRINGS_PROJECT_URL,
      locales: SUPPORTED_LOCALES
    )
  end

  # This lane finalizes a release: updates store metadata and runs the release checks.
  #
  # @param [Boolean] skip_confirm (default: false) If set, will skip the confirmation prompt before running the rest of the lane
  # @param [Boolean] include_wear_app (default: false) If true, the CI build will also include a job to build the WEAR_APP
  #
  # @example Running the lane
  #          bundle exec fastlane finalize_release skip_confirm:true include_wear_app:true
  #
  lane :finalize_release do |skip_confirm: false, include_wear_app: false|
    UI.user_error!('Please use `finalize_hotfix_release` lane for hotfixes') if android_current_branch_is_hotfix(version_properties_path: VERSION_PROPERTIES_PATH)

    # Verify that there's nothing in progress in the working copy
    ensure_git_status_clean

    ensure_git_branch_is_release_branch

    UI.important("Finalizing release: #{release_version_current}")
    UI.user_error!("Terminating as requested. Don't forget to run the remainder of this automation manually.") unless skip_confirm || UI.confirm('Do you want to continue?')

    configure_apply(force: is_ci)

    # Don't check translation coverage in CI
    check_translation_progress_all unless is_ci
    download_translations

    # Bump the release version and build code
    UI.message 'Bumping final release version and build code...'
    VERSION_FILE.write_version(
      version_name: release_version_current,
      version_code: build_code_next
    )
    commit_version_bump
    UI.success("Done! New Release Version: #{release_version_current}. New Build Code: #{build_code_current}")

    version = release_version_current

    download_metadata_strings(version: version, app: MOBILE_APP)
    download_metadata_strings(version: version, app: WEAR_APP) if include_wear_app

    # Start the build
    UI.important('Pushing changes to remote and triggering the release build')
    UI.user_error!("Terminating as requested. Don't forget to run the remainder of this automation manually.") unless skip_confirm || UI.confirm('Do you want to continue?')

    push_to_git_remote(tags: false)

    trigger_release_build(branch_to_build: "release/#{version}", include_wear_app: include_wear_app)

    create_backmerge_pr(version: version)

    # Close milestone
    begin
      remove_branch_protection(
        repository: GITHUB_REPO,
        branch: "release/#{version}"
      )
      set_milestone_frozen_marker(
        repository: GITHUB_REPO,
        milestone: version,
        freeze: false
      )
      close_milestone(
        repository: GITHUB_REPO,
        milestone: version
      )
    rescue StandardError => e
      error_message = <<-MESSAGE
        Error closing milestone `#{app_version}`: #{e.message}
        - If this is a retry of the lane, the milestone might have already been closed and this error is expected.
        - If this is the first run of the lane, please investigate the error.
      MESSAGE

      UI.error(error_message)

      buildkite_annotate(style: 'warning', context: 'finalize-release-error-milestone', message: error_message) if is_ci
    end
  end

  lane :check_translation_progress_all do
    check_translation_progress_strings
    check_translation_progress_release_notes
  end

  lane :check_translation_progress_strings do
    UI.message('Checking app strings translation status...')
    check_translation_progress(
      glotpress_url: GLOTPRESS_APP_STRINGS_PROJECT_URL,
      abort_on_violations: false
    )
  end

  lane :check_translation_progress_release_notes do
    UI.message('Checking release notes strings translation status...')
    check_translation_progress(
      glotpress_url: GLOTPRESS_PLAYSTORE_METADATA_PROJECT_URL,
      abort_on_violations: false
    )
  end

  #####################################################################################
  # build_and_upload_google_play
  #
  # This lane builds the app for Google Play, and will correctly select which build
  # should be produced based on the build number.
  #
  # @param [String] app The Android app to build (MOBILE_APP aka 'WooCommerce' or WEAR_APP aka 'WooCommerce-Wear')
  #
  desc 'Builds and uploads a release to Google Play'
  lane :build_and_upload_google_play do |options|
    app = get_app_param!(options)
    if beta_version?(version_name_current)
      build_and_upload_beta(
        app: app,
        skip_confirm: is_ci,
        skip_prechecks: true,
        create_release: true
      )
    else
      build_and_upload_release(
        app: app,
        skip_confirm: is_ci,
        skip_prechecks: true,
        create_release: true
      )
    end
  end

  #####################################################################################
  # build_and_upload_release
  #
  # This lane builds the final release of the app and uploads it to the Google Play Console
  #
  # @param [String] app The Android app to build (MOBILE_APP aka 'WooCommerce' or WEAR_APP aka 'WooCommerce-Wear')
  # @param [Boolean] skip_confirm If set to true, will not prompt for confirmation before moving forward with the build
  # @param [Boolean] skip_prechecks If set to true, will skip the `android_build_preflight` action
  # @param [Boolean] create_release If set to true, will create a GitHub Release once the release has been uploaded to Play Store
  #
  desc 'Builds and uploads release for distribution'
  lane :build_and_upload_release do |options|
    ensure_git_branch_is_release_branch unless is_ci

    UI.user_error!("Can't build a final release out of this branch because it's configured as a beta release!") if beta_version?(version_name_current)

    ensure_git_status_clean unless is_ci

    app = get_app_param!(options)
    message = "Building `#{app}` version #{release_version_current} (#{build_code_current}) for upload to Release Channel"

    UI.important(message)
    unless options[:skip_confirm] || UI.confirm('Do you want to continue?')
      UI.user_error!("Terminating as requested. Don't forget to run the remainder of this automation manually.")
    end

    android_build_preflight unless options[:skip_prechecks]

    # Create the file names
    version = version_name_current
    aab_file_path = build_bundle(app: app, version: version, flavor: 'Vanilla')

    UI.error("Unable to find a build artifact at #{aab_file_path}") unless File.exist? aab_file_path

    upload_to_play_store(
      package_name: APP_PACKAGE_NAME,
      aab: aab_file_path,
      track: track(app: app, track_name: 'production'),
      release_status: 'inProgress',
      rollout: '0.1', # Start the production rollout at 10%
      metadata_path: METADATA_DIR_PATH[app],
      # Skip uploading Play Store listing metadata for the Wear app, as these are shared with the Mobile app and
      # stored in its metadata folder. The Wear app only has separate changelogs.
      skip_upload_metadata: app == WEAR_APP,
      skip_upload_changelogs: false,
      skip_upload_images: true,
      skip_upload_screenshots: true,
      json_key: UPLOAD_TO_PLAY_STORE_JSON_KEY
    )

    create_gh_release(app: app, version: version) if options[:create_release]
  end

  #####################################################################################
  # build_and_upload_beta
  #
  # This lane builds the app for external beta distribution, and uploads the build
  # to the beta channel (but does not release it).
  #
  # @param [String] app The Android app to build (MOBILE_APP aka 'WooCommerce' or WEAR_APP aka 'WooCommerce-Wear')
  # @param [Boolean] skip_confirm If set to true, will not prompt for confirmation before moving forward with the build
  # @param [Boolean] skip_prechecks If set to true, will skip the `android_build_preflight` action
  # @param [Boolean] create_release If set to true, will create a GitHub Release once the release has been uploaded to Play Store
  #
  desc 'Builds and uploads a new beta build to Google Play (without releasing it)'
  lane :build_and_upload_beta do |options|
    ensure_git_branch_is_release_branch unless is_ci

    ensure_git_status_clean unless is_ci

    app = get_app_param!(options)
    message = "Building `#{app}` version #{version_name_current} (#{build_code_current}) for upload to Beta Channel"

    UI.important(message)
    unless options[:skip_confirm] || UI.confirm('Do you want to continue?')
      UI.user_error!("Terminating as requested. Don't forget to run the remainder of this automation manually.")
    end

    android_build_preflight unless options[:skip_prechecks]

    # Create the file names
    version = version_name_current
    aab_file_path = build_bundle(app: app, version: version, flavor: 'Vanilla')

    UI.error("Unable to find a build artifact at #{aab_file_path}") unless File.exist? aab_file_path

    upload_to_play_store(
      package_name: APP_PACKAGE_NAME,
      aab: aab_file_path,
      track: track(app: app, track_name: 'beta'),
      release_status: 'completed',
      rollout: '1.0', # Rollout to 100% of testers on the beta track
      metadata_path: METADATA_DIR_PATH[app],
      skip_upload_metadata: true,
      skip_upload_changelogs: true,
      skip_upload_images: true,
      skip_upload_screenshots: true,
      json_key: UPLOAD_TO_PLAY_STORE_JSON_KEY
    )

    create_gh_release(app: app, version: version, prerelease: true) if options[:create_release]
  end

  # This lane triggers a stable release build on CI.
  #
  # @param [String] branch_to_build The git branch the CI build should run on. Defaults to the current branch at the time of calling the lane.
  # @param [Boolean] include_wear_app (default: false) If true, the CI build will also include a job to build the WEAR_APP
  #
  # @example Running the lane
  #          bundle exec fastlane trigger_release_build branch_to_build:main include_wear_app:true
  #
  lane :trigger_release_build do |branch_to_build: nil, include_wear_app: false|
    branch = branch_to_build || git_branch

    build_url = buildkite_trigger_build(
      buildkite_organization: 'automattic',
      buildkite_pipeline: 'woocommerce-android',
      branch: branch,
      pipeline_file: 'release-builds.yml',
      environment: { INCLUDE_WEAR_APP: include_wear_app }
    )

    message = "This build triggered a release build on <code>#{branch}</code>:<br>- #{build_url}"
    buildkite_annotate(style: 'info', context: 'trigger-release-build-doandroid', message: message) if is_ci
  end

  #####################################################################################
  # localize_libs
  #
  # This lane gets the data from the dependencies and updates the main `strings.xml` file,
  # so that they are included when that file is sent to GlotPress for translation.
  #
  # @example fastlane localize_libs
  #
  desc 'Merge libraries strings files into the main app one'
  lane :localize_libs do
    REMOTE_LIBRARIES_STRINGS_PATHS.each do |lib|
      download_path = android_download_file_by_version(
        library_name: lib[:name],
        import_key: lib[:import_key],
        repository: lib[:repository],
        file_path: lib[:strings_file_path],
        build_gradle_path: BUILD_GRADLE_PATH
      )

      if download_path.nil?
        error_message = <<~ERROR
          Can't download strings file for #{lib[:name]}.
          Strings for this library won't get translated.
          Do you want to continue anyway?
        ERROR
        UI.user_error! 'Abort.' unless UI.confirm(error_message)
      else
        UI.message("Strings.xml file for #{lib[:name]} downloaded to #{download_path}.")
        lib_to_merge = [{
          library: lib[:name],
          strings_path: download_path,
          exclusions: lib[:exclusions]
        }]
        an_localize_libs(app_strings_path: MAIN_STRINGS_PATH, libs_strings_path: lib_to_merge)
        FileUtils.rm_f(download_path)
      end
    end

    git_commit(
      path: MAIN_STRINGS_PATH,
      message: 'Include lib strings for translation',
      allow_nothing_to_commit: true
    )
  end

  # This lane downloads the translated metadata (release notes, app store strings, title, etc.) from GlotPress and updates the local files.
  #
  # @param [String] version the version for which to download metadata
  # @param [String] app (default: WooCommerce) The Android app to build (MOBILE_APP aka 'WooCommerce' or WEAR_APP aka 'WooCommerce-Wear')
  #
  # @example Running the lane
  #          bundle exec fastlane download_metadata_strings version:10.3 app:'WooCommerce-Wear'
  #
  lane :download_metadata_strings do |version:, app: MOBILE_APP|
    values = version.split('.')

    files = case app
            when MOBILE_APP
              {
                "release_note_#{values[0].to_s.rjust(2, '0')}#{values[1]}" => { desc: 'changelogs/default.txt', max_size: 500 },
                play_store_promo: { desc: 'short_description.txt', max_size: 80 },
                play_store_desc: { desc: 'full_description.txt', max_size: 0 },
                play_store_app_title: { desc: 'title.txt', max_size: 50 }
              }
            when WEAR_APP
              { wear_release_note: { desc: 'changelogs/default.txt', max_size: 500 } }
            else
              UI.user_error!("Unknown app parameter: #{app}. Must me one of #{MOBILE_APP} or #{WEAR_APP}")
            end

    download_path = METADATA_DIR_PATH[app]
    gp_downloadmetadata(
      project_url: GLOTPRESS_PLAYSTORE_METADATA_PROJECT_URL,
      target_files: files,
      locales: SUPPORTED_LOCALES.map { |hsh| [hsh[:glotpress], hsh[:google_play]] },
      download_path: download_path
    )

    # We need to explicitly call `git_add`, despite the path being passed to `git_commit` as well.
    # That's because we might have new files, that the commit command would otherwise miss.
    git_add(path: download_path)
    git_commit(
      path: download_path,
      message: "Update metadata translations for #{app} #{version}",
      allow_nothing_to_commit: true
    )

    UI.important('Pushing changes to remote')
    UI.user_error!("Terminating as requested. Don't forget to run the remainder of this automation manually.") unless is_ci || UI.confirm('Do you want to continue?')

    push_to_git_remote(tags: false)
  end

  ########################################################################
  # Helper Lanes
  ########################################################################

  #####################################################################################
  # build_bundle
  #
  # This lane builds an app bundle
  #
  # @param [String] app The Android app to build (MOBILE_APP aka 'WooCommerce' or WEAR_APP aka 'WooCommerce-Wear')
  # @param [String] version The version to create
  # @param [String] flavor The flavor of app ('Wasabi', 'Jalapeno' or 'Vanilla'; defaults to 'Vanilla')
  #
  desc 'Builds an app bundle'
  lane :build_bundle do |options|
    # Create the file names
    app = get_app_param!(options)
    version = options[:version]
    flavor = options.fetch(:flavor, 'Vanilla')
    output_dir = File.join(app, 'build', 'outputs', 'bundle')
    output_aab_file = "#{app}-#{flavor.downcase}-release.aab" # the file name generated by the gradle build
    artifact_final_path = File.join(PROJECT_ROOT_FOLDER, 'artifacts', aab_file_name(app, version))

    # Build
    Dir.chdir('.') do
      UI.message('Cleaning branch...')
      gradle(task: 'clean')
      UI.message('Running lint...')
      gradle(task: 'lint', flavor: flavor, build_type: 'Release')
      UI.message("Building #{app} #{version} / #{build_code_current} - #{output_aab_file}...")
      gradle(task: ":#{app}:bundle", flavor: flavor, build_type: 'Release')
    end

    Dir.chdir('..') do
      FileUtils.mkdir_p(File.dirname(artifact_final_path))
      FileUtils.cp(File.join(output_dir, "#{flavor.downcase}Release", output_aab_file), artifact_final_path)
      UI.message("Bundle ready: #{artifact_final_path}")
    end
    artifact_final_path
  end

  #####################################################################################
  # screenshots
  # -----------------------------------------------------------------------------------
  # This lane creates screenshots for light and dark modes
  # -----------------------------------------------------------------------------------
  # Usage:
  # fastlane take_screenshots
  #
  # Example:
  # fastlane take_screenshots
  #####################################################################################
  desc 'Create raw screenshots'
  lane :take_screenshots do |options|
    # Build the app and test targets
    gradle(task: 'assembleVanillaDebug assembleVanillaDebugAndroidTest')

    locales = if options[:locales]
                options[:locales].split(',')
              else
                SUPPORTED_LOCALES
                  .map { |locale| locale[:google_play] }
                  .append('en-US')
                # Depending on how automated this is, possibly on whether we wipe the
                # emulator before running or not, the zh-CN locale might break due to
                # Pinwin Keyboard wanting contacts access. If that's the case, you can
                # skip it by uncommeting the following line.
                # .reject { |locale| locale[:glotpress] == 'zh-cn' }
              end

    UI.message("Attempting screenshots for locales: #{locales}")

    screenshot_options = {
      output_directory: RAW_SCREENSHOTS_DIR,
      app_package_name: APP_PACKAGE_NAME,
      app_apk_path: 'WooCommerce/build/outputs/apk/vanilla/debug/WooCommerce-vanilla-debug.apk',
      tests_apk_path: 'WooCommerce/build/outputs/apk/androidTest/vanilla/debug/WooCommerce-vanilla-debug-androidTest.apk',
      use_tests_in_classes: "#{APP_PACKAGE_NAME}.screenshots.ScreenshotTest",
      reinstall_app: false,
      # By default, don't clear previous because we differentiate between light
      # and dark mode
      clear_previous_screenshots: options.fetch(:clear_previous_screenshots, false),
      # Needs to be root to save screenshots consistently
      use_adb_root: true,
      locales: locales,
      use_timestamp_suffix: false,
      test_instrumentation_runner: "#{APP_PACKAGE_NAME}.WooCommerceTestRunner",
      # Don't care about the .html summary
      skip_open_summary: true
    }

    UI.message('Taking screenshots for Dark theme...')
    begin
      adb(command: 'shell cmd uimode night yes')
    rescue StandardError => e
      # Skip any error here
      UI.error(e)
    end
    screengrab(
      screenshot_options.merge(
        {
          launch_arguments: ['theme dark']
        }
      )
    )

    UI.message('Taking screenshots for Light theme...')
    begin
      adb(command: 'shell cmd uimode night no')
    rescue StandardError => e
      # Skip any error here
      UI.error(e)
    end
    screengrab(
      screenshot_options.merge(
        {
          launch_arguments: ['theme light']
        }
      )
    )
  end

  # This lane downloads the translated promo strings from the translation system.
  #
  lane :download_promo_strings do
    # "<key in .po file>" => { desc: "<name of txt file>" }
    files = {
      play_store_screenshot_1: { desc: 'promo_screenshot_1.txt' },
      play_store_screenshot_2: { desc: 'promo_screenshot_2.txt' },
      play_store_screenshot_3: { desc: 'promo_screenshot_3.txt' },
      play_store_screenshot_4: { desc: 'promo_screenshot_4.txt' },
      play_store_screenshot_5: { desc: 'promo_screenshot_5.txt' }
    }

    locales = SUPPORTED_LOCALES
              .reject { |hsh| hsh[:promo_config] == false }
              .map { |hsh| [hsh[:glotpress], hsh[:google_play]] }

    gp_downloadmetadata(project_url: GLOTPRESS_PLAYSTORE_METADATA_PROJECT_URL,
                        target_files: files,
                        locales: locales,
                        source_locale: 'en-US',
                        download_path: METADATA_DIR_PATH[MOBILE_APP])
  end

  #####################################################################################
  # build_and_instrumented_test
  # -----------------------------------------------------------------------------------
  # Run instrumented tests in Google Firebase Test Lab
  # -----------------------------------------------------------------------------------
  # Usage:
  # bundle exec fastlane build_and_instrumented_test
  #
  #####################################################################################
  desc 'Build the application and instrumented tests, then run the tests in Firebase Test Lab'
  lane :build_and_instrumented_test do
    gradle(tasks: %w[assembleVanillaDebug assembleVanillaDebugAndroidTest])

    annotation_ctx = 'firebase-test-woocommerce-vanilla-debug'
    begin
      gradle(task: 'runFlank')
      sh("buildkite-agent annotation remove --context '#{annotation_ctx}' || true") if is_ci?
    rescue StandardError
      details_url = sh('jq', '.[].webLink', '../build/instrumented-tests/matrix_ids.json', '-r')
      message = "Firebase Tests failed. Failure details can be seen [here in Firebase Console](#{details_url})"
      sh('buildkite-agent', 'annotate', message, '--style', 'error', '--context', annotation_ctx) if is_ci?
      UI.test_failure!(message)
    end
  end

  #####################################################################################
  # create_promo_screenshots
  # -----------------------------------------------------------------------------------
  # This lane creates the promo screenshot from the original ones that
  # are taken by the screenshot lane
  # -----------------------------------------------------------------------------------
  # Usage:
  # fastlane create_promo_screenshots
  #
  # Example:
  # fastlane create_promo_screenshots
  #####################################################################################
  desc 'Creates promo screenshots'
  lane :create_promo_screenshots do |options|
    begin
      fastlane_require 'rmagick'
    rescue LoadError
      UI.user_error!("The rmagick gem doesn't seem to be installed. Be sure to use `bundle install --with screenshots`.")
    end

    # Clean temporary folder from previous runs
    FileUtils.rm_rf(PROMO_SCREENSHOTS_DIR)

    # Create a copy of the files to work with – this ensures that if we're doing multiple
    # screenshot generation tasks close together, we can keep reusing the same source files
    FileUtils.rm_rf(RAW_SCREENSHOTS_PROCESSING_DIR)
    FileUtils.copy_entry(RAW_SCREENSHOTS_DIR, RAW_SCREENSHOTS_PROCESSING_DIR)

    locales = SUPPORTED_LOCALES
              .reject { |hsh| hsh[:promo_config] == false }
              .map { |hsh| hsh[:google_play] }
              .append('en-US')

    # Allow creating promo screenshots for just one locale
    unless options[:locale].nil?
      locales.keep_if do |locale|
        locale.casecmp(options[:locale]).zero?
      end
    end

    UI.message("Creating promo screenshots for Locales: #{locales}")

    # Remove locales we're not interested in
    Pathname(RAW_SCREENSHOTS_PROCESSING_DIR)
      .children
      .select(&:directory?)
      .reject { |dir| locales.include? File.basename(dir) }
      .each do |dir|
      FileUtils.rm_rf(dir)
    end

    # Run screenshots generator tool
    promo_screenshots(
      orig_folder: RAW_SCREENSHOTS_PROCESSING_DIR,
      metadata_folder: METADATA_DIR_PATH[MOBILE_APP], # not considering wear app
      output_folder: PROMO_SCREENSHOTS_DIR,
      force: options[:force]
    )

    # Clean up the temp directories
    FileUtils.rm_rf(RAW_SCREENSHOTS_PROCESSING_DIR)
  end

  #####################################################################################
  # build_and_upload_prototype_build
  #
  # This lane builds a prototype build and uploads it to S3
  #
  # @param [String] app The Android app to build (MOBILE_APP aka 'WooCommerce' or WEAR_APP aka 'WooCommerce-Wear')
  #
  desc 'Builds a prototype build and uploads it to S3'
  lane :build_and_upload_prototype_build do |options|
    UI.user_error!("'BUILDKITE_ARTIFACTS_S3_BUCKET' must be defined as an environment variable.") unless ENV['BUILDKITE_ARTIFACTS_S3_BUCKET']

    app = get_app_param!(options)
    prototype_flavor = 'Jalapeno'
    prototype_build_type = 'Debug'

    gradle(
      task: ":#{app}:assemble",
      flavor: prototype_flavor,
      build_type: prototype_build_type
    )

    upload_path = upload_to_s3(
      bucket: 'a8c-apps-public-artifacts',
      key: "#{app.downcase}-prototype-build-#{generate_prototype_build_number}.apk",
      file: lane_context[SharedValues::GRADLE_APK_OUTPUT_PATH],
      skip_if_exists: true
    )

    install_url = "#{PROTOTYPE_BUILD_DOMAIN}/#{upload_path}"
    platform_name = { WEAR_APP => '⌚️ Wear OS', MOBILE_APP => '📱 Mobile' }.fetch(app, '_(Unknown)_')
    comment_body = prototype_build_details_comment(
      app_display_name: "#{app} Android",
      download_url: install_url,
      metadata: {
        Platform: platform_name,
        Flavor: prototype_flavor,
        'Build Type': prototype_build_type
      },
      fold: app == WEAR_APP # Keep comment for Mobile app always expanded, but collapse comment for Wear app by default, as it's modified less often
    )

    unless ENV['BUILDKITE_PULL_REQUEST'].nil?
      comment_on_pr(
        project: 'woocommerce/woocommerce-android',
        pr_number: Integer(ENV['BUILDKITE_PULL_REQUEST']),
        reuse_identifier: "#{app}-prototype-build-link",
        body: comment_body
      )
    end
  end

  #####################################################################################
  # Private lanes
  #####################################################################################

  # Creates a new GitHub Release for the given version. The name (and tag) of the release will be exactly as
  # the `version` parameter, with a `w` appended in the case of a Wear OS app.
  #
  # @param [String] app The Android app to create the release for (`MOBILE_APP` or `WEAR_APP`)
  # @param [String] version The version of the app, as in the `versionName` property from `version.properties`.
  # @param [Boolean] prerelease If true, the GitHub Release will have the prerelease flag
  #
  # @example Running the lane
  #          bundle exec fastlane create_gh_release app:WEAR_APP version:1.0.0 prerelease:true
  #
  private_lane :create_gh_release do |app:, version:, prerelease: false|
    validate_app_param!(app)

    universal_apk_path = File.join(PROJECT_ROOT_FOLDER, 'artifacts', universal_apk_name(app, version))

    # We have a convention that the Wear app's version code is offset by 50000 from the Mobile app's one
    # See https://github.com/woocommerce/woocommerce-android/blob/11ae376f2922e4b2eac3f87971b8c2246e56b37b/WooCommerce-Wear/build.gradle#L29
    version_code_offset = { MOBILE_APP => 0, WEAR_APP => 50_000 }.fetch(app, 0)
    download_universal_apk_from_google_play(
      package_name: APP_PACKAGE_NAME,
      version_code: build_code_current.to_i + version_code_offset,
      destination: universal_apk_path,
      json_key: UPLOAD_TO_PLAY_STORE_JSON_KEY
    )

    aab_file_path = File.join(PROJECT_ROOT_FOLDER, 'artifacts', aab_file_name(app, version))
    release_assets = [universal_apk_path, aab_file_path].compact

    create_release(
      repository: GITHUB_REPO,
      # 'version' is used for the release name as well as the tag that's going to be created for the release
      version: app == WEAR_APP ? "#{version}w" : version,
      release_notes_file_path: METADATA_SOURCE_CHANGELOG_FILE_PATH[app],
      prerelease: prerelease,
      release_assets: release_assets.join(',')
    )
  end

  # Copy the original English `strings.xml` file into the location from where the WPCOM job will pick them
  #
  # The reason for the WPCOM job to import the file from `FROZEN_STRINGS_PATH` and not `MAIN_STRINGS_PATH` is so
  # that it picks the file's content as it was at the time of code freeze, and does not risk picking up changes
  # that could be made to the `MAIN_STRINGS_PATH` file on `trunk` _after_ code freeze, by devs working on features.
  #
  # A WPCOM job is responsible to import the `FROZEN_STRINGS_PATH` file into GlotPress (as opposed to e.g. us sending them via API).
  # Note: If you decide to change the path to `FROZEN_STRINGS_PATH` at some point, ensure you also update it in the WPCOM job:
  #       https://opengrok.a8c.com/source/xref/wpcom/bin/i18n/import-github-originals.php?r=accd6334#33
  #
  private_lane :freeze_strings_for_translation do
    FileUtils.mkdir_p(File.dirname(FROZEN_STRINGS_PATH))
    FileUtils.cp(MAIN_STRINGS_PATH, FROZEN_STRINGS_PATH)
    git_add(path: FROZEN_STRINGS_PATH)
    git_commit(
      path: FROZEN_STRINGS_PATH,
      message: 'Freeze strings for translation',
      allow_nothing_to_commit: true
    )
  end

  #####################################################################################
  # Utils
  #####################################################################################
  def validate_app_param!(app)
    return if [MOBILE_APP, WEAR_APP].include?(app)

    UI.user_error!("Invalid or missing `app` parameter. Please provide one of `#{MOBILE_APP}` or `#{WEAR_APP}`")
  end

  def get_app_param!(options)
    validate_app_param!(options[:app])
    options[:app]
  end

  def aab_file_name(app, version)
    "#{app}-#{version}.aab"
  end

  def universal_apk_name(app, version)
    "#{app}-#{version}-universal.apk"
  end

  # @param [String] app The type of app (`MOBILE_APP` or `WEAR_APP`)
  # @param [String] track_name The track name, e.g. `'beta'` or `'production'`
  def track(app:, track_name:)
    validate_app_param!(app)

    prefix = { WEAR_APP => 'wear:', MOBILE_APP => '' }.fetch(app, nil)
    "#{prefix}#{track_name}"
  end

  def beta_version?(version)
    version.include? '-rc-'
  end

  def firebase_secret(name:)
    UI.user_error!('Unable to locale Firebase Secrets File – did you run `configure apply`?') unless File.file? GOOGLE_FIREBASE_SECRETS_PATH
    key_file_secrets = JSON.parse(File.read(GOOGLE_FIREBASE_SECRETS_PATH))
    UI.user_error!("Unable to find key `#{name}` in #{GOOGLE_FIREBASE_SECRETS_PATH}") if key_file_secrets[name].nil?
    key_file_secrets[name]
  end

  # This function is Buildkite-specific
  def generate_prototype_build_number
    if ENV['BUILDKITE']
      commit = ENV.fetch('BUILDKITE_COMMIT', nil)[0, 7]
      branch = ENV['BUILDKITE_BRANCH'].parameterize
      pr_num = ENV.fetch('BUILDKITE_PULL_REQUEST', nil)

      pr_num == 'false' ? "#{branch}-#{commit}" : "pr#{pr_num}-#{commit}"
    else
      repo = Git.open(PROJECT_ROOT_FOLDER)
      commit = repo.current_branch.parameterize
      branch = repo.revparse('HEAD')[0, 7]

      "#{branch}-#{commit}"
    end
  end

  # Remove old `changelogs/default.txt` files for every locale except en-US.
  # After updating the en-US copy for a new version and sending it for translation,
  # we want to avoid having outdated translations in git in the meantime.
  #
  # @return [Array<String>] A list of file paths that were deleted.
  def delete_old_changelogs
    obsolete_changelogs = [MOBILE_APP, WEAR_APP].flat_map do |app|
      Dir.glob(File.join(METADATA_DIR_PATH[app], '*', 'changelogs', 'default.txt'))
         .reject { |file| File.basename(File.dirname(file, 2)) == 'en-US' }
    end
    FileUtils.rm_f(obsolete_changelogs)
    obsolete_changelogs
  end

  #####################################################################################
  # Version Methods
  #####################################################################################

  def commit_version_bump
    git_commit(
      path: VERSION_PROPERTIES_PATH,
      message: 'Bump version number',
      allow_nothing_to_commit: false
    )
  end

  # Returns the current version name from `version.properties` without needing formatting or calculations
  def version_name_current
    VERSION_FILE.read_version_name
  end

  # Returns the release version of the app in the format `1.2` or `1.2.3` if it is a hotfix
  #
  def release_version_current
    # Read the current release version from `version.properties` and parse it into an AppVersion object
    current_version = VERSION_FORMATTER.parse(VERSION_FILE.read_version_name)
    # Return the formatted release version
    VERSION_FORMATTER.release_version(current_version)
  end

  #  Returns the next release version of the app in the format `1.2` or `1.2.3` if it is a hotfix
  #
  def release_version_next
    # Read the current release version from `version.properties` and parse it into an AppVersion object
    current_version = VERSION_FORMATTER.parse(VERSION_FILE.read_version_name)
    # Calculate the next release version
    release_version_next = VERSION_CALCULATOR.next_release_version(version: current_version)
    # Return the formatted release version
    VERSION_FORMATTER.release_version(release_version_next)
  end

  # Returns the beta version that is used by the code freeze
  # It first increments the minor number, which also resets the build number to 0
  # It then bumps the build number so the -rc-1 can be appended to the code freeze version
  def beta_version_first
    # Read the current release version from `version.properties` and parse it into an AppVersion object
    current_version = VERSION_FORMATTER.parse(VERSION_FILE.read_version_name)
    # Calculate the next major version number
    next_version = VERSION_CALCULATOR.next_release_version(version: current_version)
    # Calculate the next build number
    beta_version_first = VERSION_CALCULATOR.next_build_number(version: next_version)
    # Return the formatted release version
    VERSION_FORMATTER.beta_version(beta_version_first)
  end

  # Returns the beta version of the app in the format `1.2-rc-1`
  #
  def beta_version_next
    # Read the current release version from `version.properties` and parse it into an AppVersion object
    current_version = VERSION_FORMATTER.parse(VERSION_FILE.read_version_name)
    # Calculate the next beta version
    beta_version_next = VERSION_CALCULATOR.next_build_number(version: current_version)
    # Return the formatted release version
    VERSION_FORMATTER.beta_version(beta_version_next)
  end

  # Returns the current build code of the app
  #
  def build_code_current
    # Read the current build code from `version.properties` into to a BuildCode object
    build_code_current = VERSION_FILE.read_version_code
    # Return the formatted build code
    BUILD_CODE_FORMATTER.build_code(build_code: build_code_current)
  end

  # Returns the next build code of the app
  #
  def build_code_next
    # Read the current build code from `version.properties` into to a BuildCode object
    build_code_current = VERSION_FILE.read_version_code
    # Calculate the next build code
    build_code_next = BUILD_CODE_CALCULATOR.next_build_code(build_code: build_code_current)
    # Return the formatted build code
    BUILD_CODE_FORMATTER.build_code(build_code: build_code_next)
  end
end

# -----------------------------------------------------------------------------------
# Release Management Utils
# -----------------------------------------------------------------------------------
def create_backmerge_pr(version:)
  create_release_backmerge_pull_request(
    repository: GITHUB_REPO,
    source_branch: "release/#{version}",
    labels: ['Releases'],
    milestone_title: version
  )
end

def ensure_git_branch_is_release_branch
  # Verify that the current branch is a release branch. Notice that `ensure_git_branch` expects a RegEx parameter
  ensure_git_branch(branch: '^release/')
end

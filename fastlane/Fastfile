# frozen_string_literal: true

default_platform(:android)
fastlane_require 'dotenv'

UI.user_error!('Please run fastlane via `bundle exec`') unless FastlaneCore::Helper.bundler?

########################################################################
# Constants
########################################################################
PROJECT_ROOT_FOLDER = File.dirname(File.expand_path(__dir__))
BUILD_GRADLE_PATH = File.join(PROJECT_ROOT_FOLDER, 'build.gradle')
BUILD_PRODUCTS_PATH = File.join(PROJECT_ROOT_FOLDER, 'artifacts')
PROTOTYPE_BUILD_DOMAIN = 'https://d2twmm2nzpx3bg.cloudfront.net'
ORIGINALS_METADATA_DIR_PATH = File.join(PROJECT_ROOT_FOLDER, 'WooCommerce', 'metadata')
RELEASE_NOTES_SOURCE_PATH = File.join(PROJECT_ROOT_FOLDER, 'RELEASE-NOTES.txt')
RELEASE_NOTES_PATH = File.join(ORIGINALS_METADATA_DIR_PATH, 'release_notes.txt')
# The `android_download_translations` action joins the `RES_DIR_PATH` with `PROJECT_ROOT_FOLDER`, so we don't want to
# add `PROJECT_ROOT_FOLDER` to the beginning of this path
RES_DIR_PATH = File.join('WooCommerce', 'src', 'main', 'res')
MAIN_STRINGS_PATH = File.join(PROJECT_ROOT_FOLDER, RES_DIR_PATH, 'values', 'strings.xml')
VERSION_PROPERTIES_PATH = File.join(PROJECT_ROOT_FOLDER, 'version.properties')
# The metadata for the Play Store live in the Fastlane folder, hence the `Dir.pwd`
PLAY_STORE_METADATA_DIR_PATH = File.join(Dir.pwd, 'metadata', 'android')
# Currently, the strings to use for the screenshots live in yet another metadata folder.
# This is suboptimal and could lead to confusion.
# See suggestions for how to improve at: https://github.com/woocommerce/woocommerce-android/pull/6907#discussion_r918144990
SCREENSHOTS_METADATA_DIR_PATH = File.join(Dir.pwd, 'playstoreres', 'metadata')
RAW_SCREENSHOTS_DIR = File.join(Dir.pwd, 'screenshots', 'raw')
RAW_SCREENSHOTS_PROCESSING_DIR = File.join(Dir.pwd, 'screenshots', 'raw_tmp')
PROMO_SCREENSHOTS_DIR = File.join(Dir.pwd, 'screenshots', 'promo_screenshots')
FROZEN_STRINGS_DIR_PATH = './fastlane/resources/values/'
REMOTE_LIBRARIES_STRINGS_PATHS = [
  {
    name: 'Login Library',
    import_key: 'wordPressLoginVersion',
    repository: 'wordpress-mobile/WordPress-Login-Flow-Android',
    strings_file_path: 'WordPressLoginFlow/src/main/res/values/strings.xml',
    exclusions: ['default_web_client_id']
  },
  {
    name: 'About Library',
    import_key: 'aboutAutomatticVersion', # key used in build.gradle to reference the version
    repository: 'Automattic/about-automattic-android',
    strings_file_path: 'library/src/main/res/values/strings.xml',
    exclusions: []
  }
].freeze

# URL of the GlotPress project containing the app's strings
GLOTPRESS_APP_STRINGS_PROJECT_URL = 'https://translate.wordpress.com/projects/woocommerce/woocommerce-android/'
# URL of the GlotPress project containing the Play Store metadata (title, keywords, release notes, …)
GLOTPRESS_PLAYSTORE_METADATA_PROJECT_URL = 'https://translate.wordpress.com/projects/woocommerce/woocommerce-android/release-notes/'

APP_PACKAGE_NAME = 'com.woocommerce.android'
GOOGLE_FIREBASE_SECRETS_PATH = File.join(PROJECT_ROOT_FOLDER, '.configure-files', 'firebase.secrets.json')

# Instantiate versioning classes
VERSION_CALCULATOR = Fastlane::Wpmreleasetoolkit::Versioning::MarketingVersionCalculator.new
VERSION_FORMATTER = Fastlane::Wpmreleasetoolkit::Versioning::RCNotationVersionFormatter.new
BUILD_CODE_FORMATTER = Fastlane::Wpmreleasetoolkit::Versioning::SimpleBuildCodeFormatter.new
BUILD_CODE_CALCULATOR = Fastlane::Wpmreleasetoolkit::Versioning::SimpleBuildCodeCalculator.new
VERSION_FILE = Fastlane::Wpmreleasetoolkit::Versioning::AndroidVersionFile.new(version_properties_path: VERSION_PROPERTIES_PATH)

# The valid values for `app:` parameter, i.e. the two possible top-level modules we can build (mobile and wear app)
MOBILE_APP = 'WooCommerce'
WEAR_APP = 'WooCommerce-Wear'

########################################################################
# Environment
########################################################################
Dotenv.load('~/.wcandroid-env.default')
GITHUB_REPO = 'woocommerce/woocommerce-android'
DEFAULT_BRANCH = 'trunk'
REPOSITORY_NAME = 'woocommerce-android'
GH_ORG_NAME = 'woocommerce'

UPLOAD_TO_PLAY_STORE_JSON_KEY = File.join(Dir.home, '.configure', 'woocommerce-android', 'secrets', 'google-upload-credentials.json')

SUPPORTED_LOCALES = [
  { glotpress: 'ar', android: 'ar', google_play: 'ar', promo_config: {} },
  { glotpress: 'de', android: 'de', google_play: 'de-DE',  promo_config: {} },
  { glotpress: 'es', android: 'es', google_play: 'es-ES',  promo_config: {} },
  { glotpress: 'fr', android: 'fr', google_play: 'fr-FR',  promo_config: {} },
  { glotpress: 'he', android: 'he', google_play: 'iw-IL',  promo_config: {} },
  { glotpress: 'id', android: 'id', google_play: 'id', promo_config: {} },
  { glotpress: 'it', android: 'it', google_play: 'it-IT',  promo_config: {} },
  { glotpress: 'ja', android: 'ja', google_play: 'ja-JP',  promo_config: {} },
  { glotpress: 'ko', android: 'ko', google_play: 'ko-KR',  promo_config: {} },
  { glotpress: 'nl', android: 'nl', google_play: 'nl-NL',  promo_config: {} },
  { glotpress: 'pt-br', android: 'pt-rBR', google_play: 'pt-BR', promo_config: {} },
  { glotpress: 'ru', android: 'ru', google_play: 'ru-RU',  promo_config: {} },
  { glotpress: 'sv', android: 'sv', google_play: 'sv-SE',  promo_config: {} },
  { glotpress: 'tr', android: 'tr', google_play: 'tr-TR',  promo_config: {} },
  { glotpress: 'zh-cn', android: 'zh-rCN', google_play: 'zh-CN',  promo_config: {} },
  { glotpress: 'zh-tw', android: 'zh-rTW', google_play: 'zh-TW',  promo_config: {} }
].freeze

platform :android do
  ########################################################################
  # Release Lanes
  ########################################################################

  #####################################################################################
  # start_code_freeze
  # -----------------------------------------------------------------------------------
  # This lane executes the steps planned on code freeze
  # -----------------------------------------------------------------------------------
  # Usage:
  # bundle exec fastlane start_code_freeze codefreeze_version:<version> [update_release_branch_version:<update flag>] [skip_confirm:<skip confirm>]
  #
  # Example:
  # bundle exec fastlane start_code_freeze
  # bundle exec fastlane start_code_freeze skip_confirm:true
  #####################################################################################
  desc 'Creates a new release branch from the current trunk'
  lane :start_code_freeze do |options|
    # Verify that there's nothing in progress in the working copy
    ensure_git_status_clean

    # Check out the up-to-date default branch, the designated starting point for the code freeze
    Fastlane::Helper::GitHelper.checkout_and_pull(DEFAULT_BRANCH)

    message = <<-MESSAGE

    Code Freeze:
      • New release branch from #{DEFAULT_BRANCH}: release/#{release_version_next}
      • Current release version and build code: #{release_version_current} (#{build_code_current}).
      • New beta version and build code: #{beta_version_first} (#{build_code_next}).

    MESSAGE

    UI.important(message)
    unless options[:skip_confirm] || UI.confirm('Do you want to continue?')
      UI.user_error!("Terminating as requested. Don't forget to run the remainder of this automation manually.")
    end

    # Create the release branch
    UI.message 'Creating release branch...'
    Fastlane::Helper::GitHelper.create_branch("release/#{release_version_next}", from: DEFAULT_BRANCH)
    UI.success("Done! New release branch is: #{git_branch}")

    # Bump the version and build code
    UI.message 'Bumping beta version and build code...'
    VERSION_FILE.write_version(
      version_name: beta_version_first,
      version_code: build_code_next
    )
    commit_version_bump
    UI.success("Done! New Beta Version: #{version_name_current}. New Build Code: #{build_code_current}")

    new_version = release_version_current

    extract_release_notes_for_version(
      version: new_version,
      release_notes_file_path: RELEASE_NOTES_SOURCE_PATH,
      extracted_notes_file_path: RELEASE_NOTES_PATH
    )
    android_update_release_notes(
      new_version: new_version,
      release_notes_file_path: RELEASE_NOTES_SOURCE_PATH
    )

    UI.important('Pushing changes to remote and configuring the release on GitHub')
    unless options[:skip_confirm] || UI.confirm('Do you want to continue?')
      UI.user_error!("Terminating as requested. Don't forget to run the remainder of this automation manually.")
    end

    push_to_git_remote(tags: false)

    # Update GitHub branch protection and milestone name
    copy_branch_protection(
      repository: GITHUB_REPO,
      from_branch: DEFAULT_BRANCH,
      to_branch: "release/#{new_version}"
    )
    setfrozentag(
      repository: GITHUB_REPO,
      milestone: new_version
    )
  end

  #####################################################################################
  # complete_code_freeze
  #
  # This lane executes the last steps planned on code freeze
  #
  # @param [Boolean] skip_confirm Skip the confirmation prompt if set to true
  # @param [Boolean] include_wear_app If true, the CI build will also include a job to build the WEAR_APP. Defaults to false.
  #
  desc 'Creates a new release branch from the current trunk'
  lane :complete_code_freeze do |options|
    # Ensure we use the latest version of the toolkit
    check_for_toolkit_updates unless is_ci || ENV['FASTLANE_SKIP_TOOLKIT_UPDATE_CHECK']

    # Verify that there's nothing in progress in the working copy
    ensure_git_status_clean

    ensure_git_branch_is_release_branch

    UI.important("Completing code freeze for: #{release_version_current}")
    unless options[:skip_confirm] || UI.confirm('Do you want to continue?')
      UI.user_error!("Terminating as requested. Don't forget to run the remainder of this automation manually.")
    end

    update_play_store_strings
    localize_libs
    send_strings_for_translation

    push_to_git_remote(tags: false)

    include_wear_app = options.fetch(:include_wear_app, false)
    trigger_release_build(branch_to_build: "release/#{release_version_current}", include_wear_app: include_wear_app)

    # Create an intermediate branch
    new_intermediate_branch_name = "merge/#{release_version_current}-code-freeze-into-#{DEFAULT_BRANCH}"
    Fastlane::Helper::GitHelper.create_branch(new_intermediate_branch_name)

    # Push up the intermediate branch
    push_to_git_remote(tags: false)

    create_release_management_pull_request(
      base_branch: DEFAULT_BRANCH,
      title: "Merge #{release_version_current} code freeze to #{DEFAULT_BRANCH}"
    )
  end

  # Updates the `PlayStoreStrings.pot` file with the latest content from the `release_notes.txt` files and the other text sources.
  #
  # @option [String] version The current `x.y` version of the app. Optional. Used to derive the `release_notes_xy` key to use in the `.pot` file.
  #
  desc 'Updates the PlayStoreStrings.pot file'
  lane :update_play_store_strings do |options|
    ensure_git_status_clean

    version = options.fetch(:version, release_version_current)

    files = {
      release_note: RELEASE_NOTES_PATH,
      play_store_promo: File.join(ORIGINALS_METADATA_DIR_PATH, 'short_description.txt'),
      play_store_desc: File.join(ORIGINALS_METADATA_DIR_PATH, 'full_description.txt'),
      play_store_app_title: File.join(ORIGINALS_METADATA_DIR_PATH, 'title.txt'),
      play_store_screenshot_1: File.join(ORIGINALS_METADATA_DIR_PATH, 'promo_screenshot_1.txt'),
      play_store_screenshot_2: File.join(ORIGINALS_METADATA_DIR_PATH, 'promo_screenshot_2.txt'),
      play_store_screenshot_3: File.join(ORIGINALS_METADATA_DIR_PATH, 'promo_screenshot_3.txt'),
      play_store_screenshot_4: File.join(ORIGINALS_METADATA_DIR_PATH, 'promo_screenshot_4.txt'),
      play_store_screenshot_5: File.join(ORIGINALS_METADATA_DIR_PATH, 'promo_screenshot_5.txt')
    }

    po_path = File.join(ORIGINALS_METADATA_DIR_PATH, 'PlayStoreStrings.pot')

    an_update_metadata_source(
      po_file_path: po_path,
      source_files: files,
      release_version: version
    )

    git_add(path: po_path)
    git_commit(
      path: po_path,
      message: "Update `PlayStoreStrings.po` for #{version}",
      allow_nothing_to_commit: true
    )
  end

  #####################################################################################
  # new_beta_release
  #
  # This lane updates the release branch for a new beta release. It will update the
  # current release branch by default.
  #
  # @param [Boolean] skip_confirm Skip the confirmation prompt if set to true
  # @param [Boolean] include_wear_app If true, the CI build will also include a job to build the WEAR_APP. Defaults to false.
  #
  desc 'Updates a release branch for a new beta release'
  lane :new_beta_release do |options|
    # Verify that there's nothing in progress in the working copy
    ensure_git_status_clean

    ensure_git_branch_is_release_branch

    # Check versions
    message = <<-MESSAGE

      Current beta version: #{version_name_current}
      New beta version: #{beta_version_next}

      Current build code: #{build_code_current}
      New build code: #{build_code_next}

    MESSAGE

    UI.important(message)
    unless options[:skip_confirm] || UI.confirm('Do you want to continue?')
      UI.user_error!("Terminating as requested. Don't forget to run the remainder of this automation manually.")
    end

    # Bump the release version and build code
    UI.message 'Bumping beta version and build code...'
    ensure_git_branch_is_release_branch
    VERSION_FILE.write_version(
      version_name: beta_version_next,
      version_code: build_code_next
    )
    commit_version_bump
    UI.success("Done! New Beta Version: #{version_name_current}. New Build Code: #{build_code_current}")

    UI.important('Pushing changes to remote and triggering the beta build')
    unless options[:skip_confirm] || UI.confirm('Do you want to continue?')
      UI.user_error!("Terminating as requested. Don't forget to run the remainder of this automation manually.")
    end

    push_to_git_remote(tags: false)

    include_wear_app = options.fetch(:include_wear_app, false)
    trigger_release_build(branch_to_build: "release/#{release_version_current}", include_wear_app: include_wear_app)

    # Create an intermediate branch
    new_intermediate_branch_name = "merge/#{version_name_current}-into-#{DEFAULT_BRANCH}"
    Fastlane::Helper::GitHelper.create_branch(new_intermediate_branch_name)

    # Push up the intermediate branch
    push_to_git_remote(tags: false)

    create_release_management_pull_request(
      base_branch: DEFAULT_BRANCH,
      title: "Merge #{version_name_current} into #{DEFAULT_BRANCH}"
    )
  end

  #####################################################################################
  # new_hotfix_release
  #
  # This lane updates the release branch for a new hotfix release.
  #
  # @param [String] version_name The versionName to give the hotfix, e.g. `24.3.1`
  # @param [Int] version_code The versionCode to use for the hotfix build
  # @param [Boolean] skip_confirm Skip the confirmation prompt if set to true
  #
  desc 'Prepare a new hotfix branch cut from the previous tag, and bump the version'
  lane :new_hotfix_release do |options|
    UI.user_error!('A `version_name` must be provided when calling this lane') if options[:version_name].nil?
    UI.user_error!('A `version_code` must be provided when calling this lane') if options[:version_code].nil?

    # Verify that there's nothing in progress in the working copy
    ensure_git_status_clean

    new_version = options[:version_name]
    version_code_new = options[:version_code]
    # Parse the provided version into an AppVersion object
    parsed_version = VERSION_FORMATTER.parse(new_version)
    previous_version = VERSION_FORMATTER.release_version(VERSION_CALCULATOR.previous_patch_version(version: parsed_version))

    # Check versions
    message = <<-MESSAGE

      Current release version: #{release_version_current}
      New hotfix version: #{new_version}

      Current build code: #{build_code_current}
      New build code: #{version_code_new}

      Branching from tag: #{previous_version}

    MESSAGE

    UI.important(message)
    unless options[:skip_confirm] || UI.confirm('Do you want to continue?')
      UI.user_error!("Terminating as requested. Don't forget to run the remainder of this automation manually.")
    end

    # Check tags
    UI.user_error!("The version `#{new_version}` tag already exists!") if git_tag_exists(tag: new_version)
    UI.user_error!("Version #{previous_version} is not tagged! A hotfix branch cannot be created.") unless git_tag_exists(tag: previous_version)

    # Create the hotfix branch
    UI.message 'Creating hotfix branch...'
    Fastlane::Helper::GitHelper.create_branch("release/#{new_version}", from: previous_version)
    UI.success("Done! New hotfix branch is: #{git_branch}")

    # Bump the hotfix version and build code and write it to the `version.properties` file
    UI.message 'Bumping hotfix version and build code...'
    VERSION_FILE.write_version(
      version_name: new_version,
      version_code: version_code_new
    )
    commit_version_bump
    UI.success("Done! New Release Version: #{release_version_current}. New Build Code: #{build_code_current}")
  end

  #####################################################################################
  # finalize_hotfix_release
  #
  # This lane finalizes the hotfix branch.
  #
  # @param [Boolean] skip_confirm Skip the confirmation prompt if set to true
  # @param [Boolean] include_wear_app If true, the CI build will also include a job to build the WEAR_APP. Defaults to false.
  #
  desc 'Finalizes a hotfix release by triggering a release build'
  lane :finalize_hotfix_release do |options|
    # Verify that there's nothing in progress in the working copy
    ensure_git_status_clean

    ensure_git_branch_is_release_branch

    hotfix_version = release_version_current

    UI.important("Pushing changes to remote and triggering hotfix build for version: #{hotfix_version}")
    unless options[:skip_confirm] || UI.confirm('Do you want to continue?')
      UI.user_error!("Terminating as requested. Don't forget to run the remainder of this automation manually.")
    end

    push_to_git_remote(tags: false)

    include_wear_app = options.fetch(:include_wear_app, false)
    trigger_release_build(branch_to_build: "release/#{hotfix_version}", include_wear_app: include_wear_app)

    # Retrieve the current non-hotfix release version
    Fastlane::Helper::GitHelper.checkout_and_pull(DEFAULT_BRANCH)
    non_hotfix_release_version = release_version_current

    # Create an intermediate branch
    Fastlane::Helper::GitHelper.checkout_and_pull("release/#{hotfix_version}")
    new_intermediate_branch_name = "merge/#{hotfix_version}-hotfix-into-release-#{non_hotfix_release_version}"
    Fastlane::Helper::GitHelper.create_branch(new_intermediate_branch_name)

    # Push up the intermediate branch
    push_to_git_remote(tags: false)

    create_release_management_pull_request(
      base_branch: "release/#{non_hotfix_release_version}",
      title: "Merge #{hotfix_version} hotfix into release/#{non_hotfix_release_version}"
    )
  end

  #####################################################################################
  # download_translations
  # -----------------------------------------------------------------------------------
  # This lane downloads the string translations from GlotPress
  # -----------------------------------------------------------------------------------
  # Usage:
  # bundle exec fastlane download_translations
  #####################################################################################
  desc 'Download the latest app translations from GlotPress and update the strings.xml files accordingly'
  lane :download_translations do |_options|
    android_download_translations(
      res_dir: RES_DIR_PATH,
      glotpress_url: GLOTPRESS_APP_STRINGS_PROJECT_URL,
      locales: SUPPORTED_LOCALES,
      lint_task: 'lintVanillaRelease'
    )
  end

  #####################################################################################
  # finalize_release
  #
  # This lane finalize a release: updates store metadata and runs the release checks
  #
  # @param [Boolean] skip_confirm Skip the confirmation prompt if set to true
  # @param [Boolean] include_wear_app If true, the CI build will also include a job to build the WEAR_APP. Defaults to false.
  #
  desc 'Updates store metadata and runs the release checks'
  lane :finalize_release do |options|
    UI.user_error!('Please use `finalize_hotfix_release` lane for hotfixes') if android_current_branch_is_hotfix(version_properties_path: VERSION_PROPERTIES_PATH)

    # Verify that there's nothing in progress in the working copy
    ensure_git_status_clean

    ensure_git_branch_is_release_branch

    UI.important("Finalizing release: #{release_version_current}")
    unless options[:skip_confirm] || UI.confirm('Do you want to continue?')
      UI.user_error!("Terminating as requested. Don't forget to run the remainder of this automation manually.")
    end

    configure_apply(force: is_ci)

    # Don't check translation coverage in CI
    check_translation_progress_all unless is_ci
    download_translations(options)

    # Bump the release version and build code
    UI.message 'Bumping final release version and build code...'
    VERSION_FILE.write_version(
      version_name: release_version_current,
      version_code: build_code_next
    )
    commit_version_bump
    UI.success("Done! New Release Version: #{release_version_current}. New Build Code: #{build_code_current}")

    version = release_version_current

    download_metadata_strings(
      version: version,
      build_number: build_code_current
    )

    # Wrap up
    remove_branch_protection(
      repository: GITHUB_REPO,
      branch: "release/#{version}"
    )
    setfrozentag(
      repository: GITHUB_REPO,
      milestone: version,
      freeze: false
    )
    create_new_milestone(
      repository: GITHUB_REPO,
      need_appstore_submission: true,
      milestone_duration: 7,
      number_of_days_from_code_freeze_to_release: 10
    )
    close_milestone(
      repository: GITHUB_REPO,
      milestone: version
    )

    # Start the build
    UI.important('Pushing changes to remote and triggering the release build')
    unless options[:skip_confirm] || UI.confirm('Do you want to continue?')
      UI.user_error!("Terminating as requested. Don't forget to run the remainder of this automation manually.")
    end

    push_to_git_remote(tags: false)

    include_wear_app = options.fetch(:include_wear_app, false)
    trigger_release_build(branch_to_build: "release/#{version}", include_wear_app: include_wear_app)

    # Create an intermediate branch
    new_intermediate_branch_name = "merge/#{release_version_current}-final-into-#{DEFAULT_BRANCH}"
    Fastlane::Helper::GitHelper.create_branch(new_intermediate_branch_name)

    # Push up the intermediate branch
    push_to_git_remote(tags: false)

    create_release_management_pull_request(
      base_branch: DEFAULT_BRANCH,
      title: "Merge #{release_version_current} final into #{DEFAULT_BRANCH}"
    )
  end

  lane :check_translation_progress_all do
    check_translation_progress_strings
    check_translation_progress_release_notes
  end

  lane :check_translation_progress_strings do
    UI.message('Checking app strings translation status...')
    check_translation_progress(
      glotpress_url: GLOTPRESS_APP_STRINGS_PROJECT_URL,
      abort_on_violations: false
    )
  end

  lane :check_translation_progress_release_notes do
    UI.message('Checking release notes strings translation status...')
    check_translation_progress(
      glotpress_url: GLOTPRESS_PLAYSTORE_METADATA_PROJECT_URL,
      abort_on_violations: false
    )
  end

  #####################################################################################
  # build_and_upload_google_play
  #
  # This lane builds the app for Google Play, and will correctly select which build
  # should be produced based on the build number.
  #
  # @param [String] app The Android app to build (MOBILE_APP aka 'WooCommerce' or WEAR_APP aka 'WooCommerce-Wear')
  #
  desc 'Builds and uploads a release to Google Play'
  lane :build_and_upload_google_play do |options|
    app = get_app_param!(options)
    if beta_version?(version_name_current)
      build_and_upload_beta(
        app: app,
        skip_confirm: is_ci,
        skip_prechecks: true,
        create_release: true
      )
    else
      build_and_upload_release(
        app: app,
        skip_confirm: is_ci,
        skip_prechecks: true,
        create_release: true
      )
    end
  end

  #####################################################################################
  # build_and_upload_release
  #
  # This lane builds the final release of the app and uploads it to the Google Play Console
  #
  # @param [String] app The Android app to build (MOBILE_APP aka 'WooCommerce' or WEAR_APP aka 'WooCommerce-Wear')
  # @param [Boolean] skip_confirm If set to true, will not prompt for confirmation before moving forward with the build
  # @param [Boolean] skip_prechecks If set to true, will skip the `android_build_preflight` action
  # @param [Boolean] create_release If set to true, will create a GitHub Release once the release has been uploaded to Play Store
  #
  desc 'Builds and uploads release for distribution'
  lane :build_and_upload_release do |options|
    ensure_git_branch_is_release_branch unless is_ci

    UI.user_error!("Can't build a final release out of this branch because it's configured as a beta release!") if beta_version?(version_name_current)

    ensure_git_status_clean unless is_ci

    app = get_app_param!(options)
    message = "Building `#{app}` version #{release_version_current} (#{build_code_current}) for upload to Release Channel"

    UI.important(message)
    unless options[:skip_confirm] || UI.confirm('Do you want to continue?')
      UI.user_error!("Terminating as requested. Don't forget to run the remainder of this automation manually.")
    end

    android_build_preflight unless options[:skip_prechecks]

    # Create the file names
    version = version_name_current
    aab_file_path = build_bundle(app: app, version: version, flavor: 'Vanilla')

    UI.error("Unable to find a build artifact at #{aab_file_path}") unless File.exist? aab_file_path

    upload_to_play_store(
      package_name: APP_PACKAGE_NAME,
      aab: aab_file_path,
      track: track(app: app, track_name: 'production'),
      release_status: 'inProgress',
      rollout: '0.1', # Start the production rollout at 10%
      skip_upload_metadata: false,
      skip_upload_changelogs: false,
      skip_upload_images: true,
      skip_upload_screenshots: true,
      json_key: UPLOAD_TO_PLAY_STORE_JSON_KEY,
      # We're retaining version 16.4 - 480 because 16.5 increases the minSDKVersion from Android 7 to Android 8
      version_codes_to_retain: [480]
    )

    create_gh_release(version: version) if options[:create_release]
  end

  #####################################################################################
  # build_and_upload_beta
  #
  # This lane builds the app for external beta distribution, and uploads the build
  # to the beta channel (but does not release it).
  #
  # @param [String] app The Android app to build (MOBILE_APP aka 'WooCommerce' or WEAR_APP aka 'WooCommerce-Wear')
  # @param [Boolean] skip_confirm If set to true, will not prompt for confirmation before moving forward with the build
  # @param [Boolean] skip_prechecks If set to true, will skip the `android_build_preflight` action
  # @param [Boolean] create_release If set to true, will create a GitHub Release once the release has been uploaded to Play Store
  #
  desc 'Builds and uploads a new beta build to Google Play (without releasing it)'
  lane :build_and_upload_beta do |options|
    ensure_git_branch_is_release_branch unless is_ci

    ensure_git_status_clean unless is_ci

    app = get_app_param!(options)
    message = "Building `#{app}` version #{version_name_current} (#{build_code_current}) for upload to Beta Channel"

    UI.important(message)
    unless options[:skip_confirm] || UI.confirm('Do you want to continue?')
      UI.user_error!("Terminating as requested. Don't forget to run the remainder of this automation manually.")
    end

    android_build_preflight unless options[:skip_prechecks]

    # Create the file names
    version = version_name_current
    aab_file_path = build_bundle(app: app, version: version, flavor: 'Vanilla')

    UI.error("Unable to find a build artifact at #{aab_file_path}") unless File.exist? aab_file_path

    upload_to_play_store(
      package_name: APP_PACKAGE_NAME,
      aab: aab_file_path,
      track: track(app: app, track_name: 'beta'),
      release_status: 'completed',
      rollout: '1.0', # Rollout to 100% of testers on the beta track
      skip_upload_metadata: true,
      skip_upload_changelogs: true,
      skip_upload_images: true,
      skip_upload_screenshots: true,
      json_key: UPLOAD_TO_PLAY_STORE_JSON_KEY
    )

    create_gh_release(version: version, prerelease: true) if options[:create_release]
  end

  #####################################################################################
  # trigger_release_build
  #
  # This lane triggers a stable release build on CI
  #
  # @param [String] branch_to_build The git branch the CI build should run on. Defaults to the current branch at the time of calling that lane.
  # @param [Boolean] include_wear_app If true, the CI build will also include a job to build the WEAR_APP. Defaults to false.
  #
  desc 'Tell Buildkite to trigger a release build'
  lane :trigger_release_build do |options|
    branch = options.fetch(:branch_to_build, git_branch)
    include_wear_app = options.fetch(:include_wear_app)

    buildkite_trigger_build(
      buildkite_organization: 'automattic',
      buildkite_pipeline: 'woocommerce-android',
      branch: branch,
      pipeline_file: 'release-builds.yml',
      environment: { INCLUDE_WEAR_APP: include_wear_app }
    )
  end

  #####################################################################################
  # localize_libs
  # -----------------------------------------------------------------------------------
  # This lane gets the data from the dependencies and updates the main strings.xml file
  # -----------------------------------------------------------------------------------
  # Usage:
  # fastlane localize_libs
  #
  # Example:
  # fastlane localize_libs
  #####################################################################################
  desc 'Merge libraries strings files into the main app one'
  lane :localize_libs do |options|
    REMOTE_LIBRARIES_STRINGS_PATHS.each do |lib|
      download_path = android_download_file_by_version(
        library_name: lib[:name],
        import_key: lib[:import_key],
        repository: lib[:repository],
        file_path: lib[:strings_file_path],
        build_gradle_path: BUILD_GRADLE_PATH
      )

      if download_path.nil?
        error_message = <<~ERROR
          Can't download strings file for #{lib[:name]}.
          Strings for this library won't get translated.
          Do you want to continue anyway?
        ERROR
        UI.user_error! 'Abort.' unless UI.confirm(error_message)
      else
        UI.message("Strings.xml file for #{lib[:name]} downloaded to #{download_path}.")
        lib_to_merge = [{
          library: lib[:name],
          strings_path: download_path,
          exclusions: lib[:exclusions]
        }]
        an_localize_libs(app_strings_path: MAIN_STRINGS_PATH, libs_strings_path: lib_to_merge)
        FileUtils.rm_f(download_path)
      end
    end

    is_repo_clean = `git status --porcelain`.empty?
    commit_strings(options) unless is_repo_clean
  end

  #####################################################################################
  # download_metadata_string
  # -----------------------------------------------------------------------------------
  # This lane downloads the translated metadata (release notes,
  # app store strings, title, etc.) from GlotPress and updates the local files
  # -----------------------------------------------------------------------------------
  # Usage:
  # fastlane download_metadata_string build_number:<build_number> version:<version>
  #
  # Example:
  # fastlane download_metadata_string build_number:573 version:10.3
  #####################################################################################
  desc 'Downloads translated metadata from GlotPress'
  lane :download_metadata_strings do |options|
    values = options[:version].split('.')
    files = {
      "release_note_#{values[0].to_s.rjust(2, '0')}#{values[1]}" => { desc: "changelogs/#{options[:build_number]}.txt", max_size: 0 },
      play_store_promo: { desc: 'short_description.txt', max_size: 80 },
      play_store_desc: { desc: 'full_description.txt', max_size: 0 },
      play_store_app_title: { desc: 'title.txt', max_size: 50 }
    }

    delete_old_changelogs(build: options[:build_number])
    download_path = PLAY_STORE_METADATA_DIR_PATH
    gp_downloadmetadata(
      project_url: GLOTPRESS_PLAYSTORE_METADATA_PROJECT_URL,
      target_files: files,
      locales: SUPPORTED_LOCALES.map { |hsh| [hsh[:glotpress], hsh[:google_play]] },
      download_path: download_path
    )

    # Copy the source `.txt` files (used as source of truth when we generated the `.po`) to the `fastlane/*metadata/android/en-US` dir,
    # as `en-US` is the source language, and isn't exported from GlotPress during `gp_downloadmetadata`
    files.each do |key, h|
      source_file = key.to_s.start_with?('release_note_') ? 'release_notes.txt' : h[:desc]
      FileUtils.cp(File.join(ORIGINALS_METADATA_DIR_PATH, source_file), File.join(download_path, 'en-US', h[:desc]))
    end

    android_create_xml_release_notes(
      download_path: download_path,
      build_number: options[:build_number].to_s,
      locales: SUPPORTED_LOCALES.to_h { |hsh| [hsh[:glotpress], hsh[:google_play]] }
    )
    add_us_release_notes(
      release_notes_path: File.join(download_path, 'release_notes.xml'),
      version_name: options[:version]
    )

    # We need to explicitly call `git_add`, despite the path being passed to `git_commit` as well.
    # That's because we might have new files, that the commit command would otherwise miss.
    git_add(path: download_path)
    git_commit(
      path: download_path,
      message: "Update metadata translations for #{options[:version]}",
      allow_nothing_to_commit: true
    )

    UI.important('Pushing changes to remote')
    UI.user_error!("Terminating as requested. Don't forget to run the remainder of this automation manually.") unless is_ci || UI.confirm('Do you want to continue?')

    push_to_git_remote(tags: false)
  end

  ########################################################################
  # Helper Lanes
  ########################################################################
  private_lane :commit_strings do |options|
    if options[:auto_commit]
      sh("cd .. && git add #{MAIN_STRINGS_PATH}")
      sh("git commit -m 'Update strings for translation'")
      sh('git push origin HEAD')
    else
      UI.important("Your #{MAIN_STRINGS_PATH} has changed.")
      UI.input('Please, review the changes, commit them and press return to continue.')
    end
  end

  #####################################################################################
  # build_bundle
  #
  # This lane builds an app bundle
  #
  # @param [String] app The Android app to build (MOBILE_APP aka 'WooCommerce' or WEAR_APP aka 'WooCommerce-Wear')
  # @param [String] version The version to create
  # @param [String] flavor The flavor of app ('Wasabi', 'Jalapeno' or 'Vanilla')
  #
  desc 'Builds an app bundle'
  lane :build_bundle do |options|
    # Create the file names
    app = get_app_param!(options)
    version = options[:version]
    output_dir = File.join(app, 'build', 'outputs', 'bundle')
    output_aab_file = "#{app}-vanilla-release.aab" # the file name generated by the gradle build
    artifact_final_path = File.join(PROJECT_ROOT_FOLDER, 'artifacts', aab_file_name(app, version))

    # Build
    Dir.chdir('.') do
      UI.message('Cleaning branch...')
      gradle(task: 'clean')
      UI.message('Running lint...')
      gradle(task: 'lint', flavor: options[:flavor], build_type: 'Release')
      UI.message("Building #{version} / #{build_code_current} - #{output_aab_file}...")
      gradle(task: 'bundle', flavor: options[:flavor], build_type: 'Release')
    end

    Dir.chdir('..') do
      FileUtils.mkdir_p(File.dirname(artifact_final_path))
      FileUtils.cp(File.join(output_dir, "#{options[:flavor].downcase}Release", output_aab_file), artifact_final_path)
      UI.message("Bundle ready: #{artifact_final_path}")
    end
    artifact_final_path
  end
  #####################################################################################
  # screenshots
  # -----------------------------------------------------------------------------------
  # This lane creates screenshots for light and dark modes
  # -----------------------------------------------------------------------------------
  # Usage:
  # fastlane take_screenshots
  #
  # Example:
  # fastlane take_screenshots
  #####################################################################################
  desc 'Create raw screenshots'
  lane :take_screenshots do |options|
    # Build the app and test targets
    gradle(task: 'assembleVanillaDebug assembleVanillaDebugAndroidTest')

    locales = if options[:locales]
                options[:locales].split(',')
              else
                SUPPORTED_LOCALES
                  .map { |locale| locale[:google_play] }
                  .append('en-US')
                # Depending on how automated this is, possibly on whether we wipe the
                # emulator before running or not, the zh-CN locale might break due to
                # Pinwin Keyboard wanting contacts access. If that's the case, you can
                # skip it by uncommeting the following line.
                # .reject { |locale| locale[:glotpress] == 'zh-cn' }
              end

    UI.message("Attempting screenshots for locales: #{locales}")

    screenshot_options = {
      output_directory: RAW_SCREENSHOTS_DIR,
      app_package_name: APP_PACKAGE_NAME,
      app_apk_path: 'WooCommerce/build/outputs/apk/vanilla/debug/WooCommerce-vanilla-debug.apk',
      tests_apk_path: 'WooCommerce/build/outputs/apk/androidTest/vanilla/debug/WooCommerce-vanilla-debug-androidTest.apk',
      use_tests_in_classes: "#{APP_PACKAGE_NAME}.screenshots.ScreenshotTest",
      reinstall_app: false,
      # By default, don't clear previous because we differentiate between light
      # and dark mode
      clear_previous_screenshots: options.fetch(:clear_previous_screenshots, false),
      # Needs to be root to save screenshots consistently
      use_adb_root: true,
      locales: locales,
      use_timestamp_suffix: false,
      test_instrumentation_runner: "#{APP_PACKAGE_NAME}.WooCommerceTestRunner",
      # Don't care about the .html summary
      skip_open_summary: true
    }

    UI.message('Taking screenshots for Dark theme...')
    begin
      adb(command: 'shell cmd uimode night yes')
    rescue StandardError => e
      # Skip any error here
      UI.error(e)
    end
    screengrab(
      screenshot_options.merge(
        {
          launch_arguments: ['theme dark']
        }
      )
    )

    UI.message('Taking screenshots for Light theme...')
    begin
      adb(command: 'shell cmd uimode night no')
    rescue StandardError => e
      # Skip any error here
      UI.error(e)
    end
    screengrab(
      screenshot_options.merge(
        {
          launch_arguments: ['theme light']
        }
      )
    )
  end

  #####################################################################################
  # download_promo_strings
  # -----------------------------------------------------------------------------------
  # This lane download the translated promo strings from the translation system
  # -----------------------------------------------------------------------------------
  # Usage:
  # fastlane download_promo_strings
  #
  # Example:
  # fastlane download_promo_strings
  #####################################################################################
  desc 'Downloads translated promo strings from the translation system'
  lane :download_promo_strings do |_options|
    # "<key in .po file>" => { desc: "<name of txt file>" }
    files = {
      play_store_screenshot_1: { desc: 'promo_screenshot_1.txt' },
      play_store_screenshot_2: { desc: 'promo_screenshot_2.txt' },
      play_store_screenshot_3: { desc: 'promo_screenshot_3.txt' },
      play_store_screenshot_4: { desc: 'promo_screenshot_4.txt' },
      play_store_screenshot_5: { desc: 'promo_screenshot_5.txt' }
    }

    locales = SUPPORTED_LOCALES
              .reject { |hsh| hsh[:promo_config] == false }
              .map { |hsh| [hsh[:glotpress], hsh[:google_play]] }

    gp_downloadmetadata(project_url: GLOTPRESS_PLAYSTORE_METADATA_PROJECT_URL,
                        target_files: files,
                        locales: locales,
                        source_locale: 'en-US',
                        download_path: SCREENSHOTS_METADATA_DIR_PATH)

    # Copy metadata (screenshot-related) txt files into `en-US`
    en_us_path = File.join(SCREENSHOTS_METADATA_DIR_PATH, 'en-US')
    FileUtils.mkdir_p(en_us_path)

    [
      'promo_screenshot_1.txt',
      'promo_screenshot_2.txt',
      'promo_screenshot_3.txt',
      'promo_screenshot_4.txt',
      'promo_screenshot_5.txt'
    ].each do |filename|
      source = File.join(ORIGINALS_METADATA_DIR_PATH, filename)
      destination = File.join(en_us_path, filename)
      FileUtils.cp(source, destination)
    end
  end

  #####################################################################################
  # build_and_instrumented_test
  # -----------------------------------------------------------------------------------
  # Run instrumented tests in Google Firebase Test Lab
  # -----------------------------------------------------------------------------------
  # Usage:
  # bundle exec fastlane build_and_instrumented_test
  #
  #####################################################################################
  desc 'Build the application and instrumented tests, then run the tests in Firebase Test Lab'
  lane :build_and_instrumented_test do |_options|
    gradle(tasks: %w[assembleVanillaDebug assembleVanillaDebugAndroidTest])

    # Run the instrumented tests in Firebase Test Lab
    firebase_login(
      key_file: GOOGLE_FIREBASE_SECRETS_PATH
    )

    apk_dir = File.join(PROJECT_ROOT_FOLDER, 'WooCommerce', 'build', 'outputs', 'apk')

    test_succeeded = android_firebase_test(
      project_id: firebase_secret(name: 'project_id'),
      key_file: GOOGLE_FIREBASE_SECRETS_PATH,
      model: 'Pixel2.arm',
      version: 30,
      test_apk_path: File.join(apk_dir, 'androidTest', 'vanilla', 'debug', 'WooCommerce-vanilla-debug-androidTest.apk'),
      apk_path: File.join(apk_dir, 'vanilla', 'debug', 'WooCommerce-vanilla-debug.apk'),
      test_targets: 'notPackage com.woocommerce.android.e2e.tests.screenshot',
      results_output_dir: File.join(PROJECT_ROOT_FOLDER, 'build', 'instrumented-tests'),
      crash_on_test_failure: false
    )

    annotation_ctx = 'firebase-test-woocommerce-vanilla-debug'
    if test_succeeded
      sh("buildkite-agent annotation remove --context '#{annotation_ctx}' || true") if is_ci?
    else
      details_url = lane_context[SharedValues::FIREBASE_TEST_MORE_DETAILS_URL]
      message = "Firebase Tests failed. Failure details can be seen [here in Firebase Console](#{details_url})"
      sh('buildkite-agent', 'annotate', message, '--style', 'error', '--context', annotation_ctx) if is_ci?
      UI.test_failure!(message)
    end
  end

  #####################################################################################
  # create_promo_screenshots
  # -----------------------------------------------------------------------------------
  # This lane creates the promo screenshot from the original ones that
  # are taken by the screenshot lane
  # -----------------------------------------------------------------------------------
  # Usage:
  # fastlane create_promo_screenshots
  #
  # Example:
  # fastlane create_promo_screenshots
  #####################################################################################
  desc 'Creates promo screenshots'
  lane :create_promo_screenshots do |options|
    begin
      fastlane_require 'rmagick'
    rescue LoadError
      UI.user_error!("The rmagick gem doesn't seem to be installed. Be sure to use `bundle install --with screenshots`.")
    end

    # Clean temporary folder from previous runs
    FileUtils.rm_rf(PROMO_SCREENSHOTS_DIR)

    # Create a copy of the files to work with – this ensures that if we're doing multiple
    # screenshot generation tasks close together, we can keep reusing the same source files
    FileUtils.rm_rf(RAW_SCREENSHOTS_PROCESSING_DIR)
    FileUtils.copy_entry(RAW_SCREENSHOTS_DIR, RAW_SCREENSHOTS_PROCESSING_DIR)

    locales = SUPPORTED_LOCALES
              .reject { |hsh| hsh[:promo_config] == false }
              .map { |hsh| hsh[:google_play] }
              .append('en-US')

    # Allow creating promo screenshots for just one locale
    unless options[:locale].nil?
      locales.keep_if do |locale|
        locale.casecmp(options[:locale]).zero?
      end
    end

    UI.message("Creating promo screenshots for Locales: #{locales}")

    # Remove locales we're not interested in
    Pathname(RAW_SCREENSHOTS_PROCESSING_DIR)
      .children
      .select(&:directory?)
      .reject { |dir| locales.include? File.basename(dir) }
      .each do |dir|
      FileUtils.rm_rf(dir)
    end

    # Run screenshots generator tool
    promo_screenshots(
      orig_folder: RAW_SCREENSHOTS_PROCESSING_DIR,
      metadata_folder: SCREENSHOTS_METADATA_DIR_PATH,
      output_folder: PROMO_SCREENSHOTS_DIR,
      force: options[:force]
    )

    # Clean up the temp directories
    FileUtils.rm_rf(RAW_SCREENSHOTS_PROCESSING_DIR)
  end

  #####################################################################################
  # build_and_upload_prototype_build
  # -----------------------------------------------------------------------------------
  # This lane builds a prototype build and uploads it to S3
  # -----------------------------------------------------------------------------------
  # Usage:
  # bundle exec fastlane build_and_upload_prototype_build
  #####################################################################################
  desc 'Builds a prototype build and uploads it to S3'
  lane :build_and_upload_prototype_build do |_options|
    UI.user_error!("'BUILDKITE_ARTIFACTS_S3_BUCKET' must be defined as an environment variable.") unless ENV['BUILDKITE_ARTIFACTS_S3_BUCKET']

    prototype_flavor = 'Jalapeno'
    prototype_build_type = 'Debug'

    gradle(
      task: 'assemble',
      flavor: prototype_flavor,
      build_type: prototype_build_type
    )

    upload_path = upload_to_s3(
      bucket: 'a8c-apps-public-artifacts',
      key: "woocommerce-prototype-build-#{generate_prototype_build_number}.apk",
      file: lane_context[SharedValues::GRADLE_APK_OUTPUT_PATH],
      skip_if_exists: true
    )

    install_url = "#{PROTOTYPE_BUILD_DOMAIN}/#{upload_path}"
    comment_body = prototype_build_details_comment(
      app_display_name: 'WooCommerce Android',
      download_url: install_url,
      metadata: {
        Flavor: prototype_flavor,
        'Build Type': prototype_build_type
      }
    )

    unless ENV['BUILDKITE_PULL_REQUEST'].nil?
      comment_on_pr(
        project: 'woocommerce/woocommerce-android',
        pr_number: Integer(ENV['BUILDKITE_PULL_REQUEST']),
        reuse_identifier: 'prototype-build-link',
        body: comment_body
      )
    end
  end

  #####################################################################################
  # Private lanes
  #####################################################################################
  private_lane :delete_old_changelogs do |options|
    Dir.glob('./metadata/android/*/').each do |folder|
      Dir["#{folder}changelogs/*"].each do |file|
        File.delete(file) if Integer(File.basename(file, '.*')) < Integer(options[:build])
      rescue StandardError
        puts "Cannot delete file #{file}"
      end
    end
  end

  private_lane :add_us_release_notes do |options|
    en_release_notes_path = RELEASE_NOTES_PATH
    File.open(options[:release_notes_path], 'a') do |f|
      f.puts('<en-US>')
      f.puts("#{options[:version_name]}:")
      f.puts(File.read(en_release_notes_path))
      f.puts('</en-US>')
    end
  end

  # Creates a new GitHub Release for the given version
  #
  # @param [String] app The Android app to create the release for (`MOBILE_APP` or `WEAR_APP`)
  # @param [String] version The version of the app.
  # @param [Bool] prerelease If true, the GitHub Release will have the prerelease flag
  #
  private_lane :create_gh_release do |options|
    app = get_app_param!(options)
    version = options[:version]
    prerelease = options[:prerelease] || false

    universal_apk_path = File.join(PROJECT_ROOT_FOLDER, 'artifacts', universal_apk_name(version))

    download_universal_apk_from_google_play(
      package_name: APP_PACKAGE_NAME,
      version_code: build_code_current,
      destination: universal_apk_path,
      json_key: UPLOAD_TO_PLAY_STORE_JSON_KEY
    )

    aab_file_path = File.join(PROJECT_ROOT_FOLDER, 'artifacts', aab_file_name(app, version))
    release_assets = [universal_apk_path, aab_file_path].compact

    create_release(
      repository: GITHUB_REPO,
      version: version,
      release_notes_file_path: RELEASE_NOTES_PATH,
      prerelease: prerelease,
      release_assets: release_assets.join(',')
    )
  end

  private_lane :send_strings_for_translation do
    sh("cd .. && mkdir -p #{FROZEN_STRINGS_DIR_PATH} && cp #{MAIN_STRINGS_PATH} #{FROZEN_STRINGS_DIR_PATH} && git add #{FROZEN_STRINGS_DIR_PATH}strings.xml")
    sh('git diff-index --quiet HEAD || git commit -m "Send strings to translation."')
    sh('git push origin HEAD')
  end

  #####################################################################################
  # Utils
  #####################################################################################
  def get_app_param!(options)
    if [MOBILE_APP, WEAR_APP].include?(options[:app])
      options[:app]
    else
      UI.user_error!("Invalid or missing `app:`. Please provide one of `app:#{MOBILE_APP}` or `app:#{WEAR_APP}`")
    end
  end

  def aab_file_name(app, version)
    "wcandroid-#{app}-#{version}.aab"
  end

  def universal_apk_name(version)
    "wcandroid-#{version}-universal.apk"
  end

  # @param [String] app The type of app (`MOBILE_APP` or `WEAR_APP`)
  # @param [String] track_name The track name, e.g. `'beta'` or `'production'`
  def track(app:, track_name:)
    prefix = app == MOBILE_APP ? '' : "#{app}:"
    "#{prefix}#{track_name}"
  end

  def beta_version?(version)
    version.include? '-rc-'
  end

  def firebase_secret(name:)
    UI.user_error!('Unable to locale Firebase Secrets File – did you run `configure apply`?') unless File.file? GOOGLE_FIREBASE_SECRETS_PATH
    key_file_secrets = JSON.parse(File.read(GOOGLE_FIREBASE_SECRETS_PATH))
    UI.user_error!("Unable to find key `#{name}` in #{GOOGLE_FIREBASE_SECRETS_PATH}") if key_file_secrets[name].nil?
    key_file_secrets[name]
  end

  # This function is Buildkite-specific
  def generate_prototype_build_number
    if ENV['BUILDKITE']
      commit = ENV.fetch('BUILDKITE_COMMIT', nil)[0, 7]
      branch = ENV['BUILDKITE_BRANCH'].parameterize
      pr_num = ENV.fetch('BUILDKITE_PULL_REQUEST', nil)

      pr_num == 'false' ? "#{branch}-#{commit}" : "pr#{pr_num}-#{commit}"
    else
      repo = Git.open(PROJECT_ROOT_FOLDER)
      commit = repo.current_branch.parameterize
      branch = repo.revparse('HEAD')[0, 7]

      "#{branch}-#{commit}"
    end
  end

  #####################################################################################
  # Version Methods
  #####################################################################################

  def commit_version_bump
    git_commit(
      path: VERSION_PROPERTIES_PATH,
      message: 'Bump version number',
      allow_nothing_to_commit: false
    )
  end

  # Returns the current version name from `version.properties` without needing formatting or calculations
  def version_name_current
    VERSION_FILE.read_version_name
  end

  # Returns the release version of the app in the format `1.2` or `1.2.3` if it is a hotfix
  #
  def release_version_current
    # Read the current release version from `version.properties` and parse it into an AppVersion object
    current_version = VERSION_FORMATTER.parse(VERSION_FILE.read_version_name)
    # Return the formatted release version
    VERSION_FORMATTER.release_version(current_version)
  end

  #  Returns the next release version of the app in the format `1.2` or `1.2.3` if it is a hotfix
  #
  def release_version_next
    # Read the current release version from `version.properties` and parse it into an AppVersion object
    current_version = VERSION_FORMATTER.parse(VERSION_FILE.read_version_name)
    # Calculate the next release version
    release_version_next = VERSION_CALCULATOR.next_release_version(version: current_version)
    # Return the formatted release version
    VERSION_FORMATTER.release_version(release_version_next)
  end

  # Returns the beta version that is used by the code freeze
  # It first increments the minor number, which also resets the build number to 0
  # It then bumps the build number so the -rc-1 can be appended to the code freeze version
  def beta_version_first
    # Read the current release version from `version.properties` and parse it into an AppVersion object
    current_version = VERSION_FORMATTER.parse(VERSION_FILE.read_version_name)
    # Calculate the next major version number
    next_version = VERSION_CALCULATOR.next_release_version(version: current_version)
    # Calculate the next build number
    beta_version_first = VERSION_CALCULATOR.next_build_number(version: next_version)
    # Return the formatted release version
    VERSION_FORMATTER.beta_version(beta_version_first)
  end

  # Returns the beta version of the app in the format `1.2-rc-1`
  #
  def beta_version_next
    # Read the current release version from `version.properties` and parse it into an AppVersion object
    current_version = VERSION_FORMATTER.parse(VERSION_FILE.read_version_name)
    # Calculate the next beta version
    beta_version_next = VERSION_CALCULATOR.next_build_number(version: current_version)
    # Return the formatted release version
    VERSION_FORMATTER.beta_version(beta_version_next)
  end

  # Returns the current build code of the app
  #
  def build_code_current
    # Read the current build code from `version.properties` into to a BuildCode object
    build_code_current = VERSION_FILE.read_version_code
    # Return the formatted build code
    BUILD_CODE_FORMATTER.build_code(build_code: build_code_current)
  end

  # Returns the next build code of the app
  #
  def build_code_next
    # Read the current build code from `version.properties` into to a BuildCode object
    build_code_current = VERSION_FILE.read_version_code
    # Calculate the next build code
    build_code_next = BUILD_CODE_CALCULATOR.next_build_code(build_code: build_code_current)
    # Return the formatted build code
    BUILD_CODE_FORMATTER.build_code(build_code: build_code_next)
  end
end

# -----------------------------------------------------------------------------------
# Release Management Utils
# -----------------------------------------------------------------------------------
def create_release_management_pull_request(base_branch:, title:)
  create_pull_request(
    api_token: ENV.fetch('GITHUB_TOKEN', nil),
    repo: GITHUB_REPO,
    title: title,
    head: Fastlane::Helper::GitHelper.current_git_branch,
    base: base_branch,
    labels: 'Releases'
  )
end

def ensure_git_branch_is_release_branch
  # Verify that the current branch is a release branch. Notice that `ensure_git_branch` expects a RegEx parameter
  ensure_git_branch(branch: '^release/')
end
